// 
// Copyright (c) 2013 Agustin Santos
// 
// Permission is hereby granted, free of charge, to any person obtaining a 
// copy of this software and associated documentation files (the "Software"), 
// to deal in the Software without restriction, including without limitation 
// the rights to use, copy, modify, merge, publish, distribute, sublicense, 
// and/or sell copies of the Software, and to permit persons to whom the 
// Software is furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included 
// in all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS 
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
// DEALINGS IN THE SOFTWARE.
//

using LibNoise.Models;
using System;
using System.Diagnostics;
using System.Drawing;
using System.Drawing.Imaging;
using System.IO;
using System.Runtime.InteropServices;
using System.Threading.Tasks;


namespace LibNoise
{
    /// @mainpage noiseutils
    ///
    /// @section intro Introduction
    ///
    /// This library contains useful classes for creating and rendering
    /// two-dimensional noise maps containing coherent noise that was
    /// generated from the libnoise library.  These classes are used to create
    /// procedural textures and terrain height maps.
    ///
    /// noiseutils is known to compile under Windows 2000 Service Pack 4
    /// (using Microsoft Visual C++ 5.0) and under Gentoo Linux 10.0 (using
    /// gcc 3.3.4).  It should be portable across all platforms that can
    /// compile libnoise.
    ///
    /// @section classes Classes
    ///
    /// This library contains the following classes:
    /// - A <i>noise map</i> class: This class implements a two-dimensional
    ///   array that stores floating-point values.  It's designed to store
    ///   coherent-noise values generated by a noise module.
    /// - Several <i>noise-map builder</i> classes: Each of these classes
    ///   fills a noise map with coherent-noise values generated by a noise
    ///   module.  While filling a noise map, it iterates the coordinates of
    ///   the input value along the surface of a specific mathematical object.
    ///   Each of these classes implements a different mathematical object,
    ///   such as a plane, a cylinder, or a sphere.
    /// - An <i>image</i> class: This class implements a two-dimensional array
    ///   that stores color values.
    /// - Several <i>image-renderer</i> classes: these classes render images
    ///   given the contents of a noise map.  Each of these classes renders an
    ///   image in a different way.
    ///
    /// @section contact Contact
    ///
    /// Contact jas for questions about noiseutils.  The spam-resistant email
    /// address is jlbezigvins@gmzigail.com (For great email, take off every
    /// <a href=http://www.planettribes.com/allyourbase/story.shtml>zig</a>.)




    /// <summary>
    /// Defines a color.
    ///
    /// A color object contains four 8-bit channels: red, green, blue, and an
    /// alpha (transparency) channel.  Channel values range from 0 to 255.
    ///
    /// The alpha channel defines the transparency of the color.  If the alpha
    /// channel has a value of 0, the color is completely transparent.  If the
    /// alpha channel has a value of 255, the color is completely opaque.
    /// </summary>
    public class Color
    {
        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="r">Value of the red channel</param>
        /// <param name="g">Value of the green channel</param>
        /// <param name="b">Value of the blue channel</param>
        /// <param name="a">Value of the alpha (transparency) channel.</param>
        public Color(byte r, byte g, byte b, byte a)
        {
            red = r;
            green = g;
            blue = b;
            alpha = a;
        }

        public Color(byte r, byte g, byte b)
        {
            red = r;
            green = g;
            blue = b;
            alpha = 255;
        }
        //public Color() { }
        /// Value of the alpha (transparency) channel.
        public byte alpha;

        /// Value of the blue channel.
        public byte blue;

        /// Value of the green channel.
        public byte green;

        /// Value of the red channel.
        public byte red;

    }

    /// Defines a point used to build a color gradient.
    ///
    /// A color gradient is a list of gradually-changing colors.  A color
    /// gradient is defined by a list of <i>gradient points</i>.  Each
    /// gradient point has a position and a color.  In a color gradient, the
    /// colors between two adjacent gradient points are linearly interpolated.
    ///
    /// The ColorGradient class defines a color gradient by a list of these
    /// objects.
    public struct GradientPoint
    {

        /// The position of this gradient point.
        public double pos;

        /// The color of this gradient point.
        public Color color;

    }

    /// Defines a color gradient.
    ///
    /// A color gradient is a list of gradually-changing colors.  A color
    /// gradient is defined by a list of <i>gradient points</i>.  Each
    /// gradient point has a position and a color.  In a color gradient, the
    /// colors between two adjacent gradient points are linearly interpolated.
    ///
    /// To add a gradient point to the color gradient, pass its position and
    /// color to the AddGradientPoint() method.
    ///
    /// To retrieve a color from a specific position in the color gradient,
    /// pass that position to the GetColor() method.
    ///
    /// This class is a useful tool for coloring height maps based on
    /// elevation.
    ///
    /// <b>Gradient example</b>
    ///
    /// Suppose a gradient object contains the following gradient points:
    /// - -1.0 maps to black.
    /// - 0.0 maps to white.
    /// - 1.0 maps to red.
    ///
    /// If an application passes -0.5 to the GetColor() method, this method
    /// will return a gray color that is halfway between black and white.
    ///
    /// If an application passes 0.25 to the GetColor() method, this method
    /// will return a very light pink color that is one quarter of the way
    /// between white and red.
    public class GradientColor
    {
        /// Constructor.
        public GradientColor()
        {
            m_pGradientPoints = null;
        }

        /// Adds a gradient point to this gradient object.
        ///
        /// @param gradientPos The position of this gradient point.
        /// @param gradientColor The color of this gradient point.
        ///
        /// @pre No two gradient points have the same position.
        ///
        /// @throw noise::ExceptionInvalidParam See the precondition.
        ///
        /// It does not matter which order these gradient points are added.
        public void AddGradientPoint(double gradientPos, Color gradientColor)
        {
            // Find the insertion point for the new gradient point and insert the new
            // gradient point at that insertion point.  The gradient point array will
            // remain sorted by gradient position.
            int insertionPos = FindInsertionPos(gradientPos);
            InsertAtPos(insertionPos, gradientPos, gradientColor);
        }

        /// Deletes all the gradient points from this gradient object.
        ///
        /// @post All gradient points from this gradient object are deleted.
        public void Clear()
        {
            //delete[] m_pGradientPoints;
            m_pGradientPoints = null;
            m_gradientPointCount = 0;
        }

        /// Returns the color at the specified position in the color gradient.
        ///
        /// @param gradientPos The specified position.
        ///
        /// @returns The color at that position.
        public Color GetColor(double gradientPos)
        {
            Debug.Assert(m_gradientPointCount >= 2);

            // Find the first element in the gradient point array that has a gradient
            // position larger than the gradient position passed to this method.
            int indexPos;
            for (indexPos = 0; indexPos < m_gradientPointCount; indexPos++)
            {
                if (gradientPos < m_pGradientPoints[indexPos].pos)
                {
                    break;
                }
            }

            // Find the two nearest gradient points so that we can perform linear
            // interpolation on the color.
            int index0 = MathHelper.Clamp(indexPos - 1, 0, m_gradientPointCount - 1);
            int index1 = MathHelper.Clamp(indexPos, 0, m_gradientPointCount - 1);

            // If some gradient points are missing (which occurs if the gradient
            // position passed to this method is greater than the largest gradient
            // position or less than the smallest gradient position in the array), get
            // the corresponding gradient color of the nearest gradient point and exit
            // now.
            if (index0 == index1)
            {
                m_workingColor = m_pGradientPoints[index1].color;
                return m_workingColor;
            }

            // Compute the alpha value used for linear interpolation.
            double input0 = m_pGradientPoints[index0].pos;
            double input1 = m_pGradientPoints[index1].pos;
            double alpha = (gradientPos - input0) / (input1 - input0);

            // Now perform the linear interpolation given the alpha value.
            Color color0 = m_pGradientPoints[index0].color;
            Color color1 = m_pGradientPoints[index1].color;
            LinearInterpColor(color0, color1, (float)alpha, out m_workingColor);
            return m_workingColor;
        }

        /// Returns a pointer to the array of gradient points in this object.
        ///
        /// @returns A pointer to the array of gradient points.
        ///
        /// Before calling this method, call GetGradientPointCount() to
        /// determine the number of gradient points in this array.
        ///
        /// It is recommended that an application does not store this pointer
        /// for later use since the pointer to the array may change if the
        /// application calls another method of this object.
        public GradientPoint[] GetGradientPointArray()
        {
            return m_pGradientPoints;
        }

        /// Returns the number of gradient points stored in this object.
        ///
        /// @returns The number of gradient points stored in this object.
        public int GetGradientPointCount()
        {
            return m_gradientPointCount;
        }

        // Performs linear interpolation between two 8-bit channel values.
        public static byte BlendChannel(byte channel0, byte channel1, float alpha)
        {
            float c0 = (float)channel0 / 255.0f;
            float c1 = (float)channel1 / 255.0f;
            return (byte)(((c1 * alpha) + (c0 * (1.0f - alpha))) * 255.0f);
        }

        // Performs linear interpolation between two colors and stores the result
        // in out.
        public static void LinearInterpColor(Color color0, Color color1,
          float alpha, out Color cout)
        {

            byte a = BlendChannel(color0.alpha, color1.alpha, alpha);
            byte b = BlendChannel(color0.blue, color1.blue, alpha);
            byte g = BlendChannel(color0.green, color1.green, alpha);
            byte r = BlendChannel(color0.red, color1.red, alpha);
            cout = new Color(r, g, b, a);
        }

        /// Determines the array index in which to insert the gradient point
        /// into the internal gradient-point array.
        ///
        /// @param gradientPos The position of this gradient point.
        ///
        /// @returns The array index in which to insert the gradient point.
        ///
        /// @pre No two gradient points have the same input value.
        ///
        /// @throw noise::ExceptionInvalidParam See the precondition.
        ///
        /// By inserting the gradient point at the returned array index, this
        /// object ensures that the gradient-point array is sorted by input
        /// value.  The code that maps a value to a color requires a sorted
        /// gradient-point array.
        private int FindInsertionPos(double gradientPos)
        {
            int insertionPos;
            for (insertionPos = 0; insertionPos < m_gradientPointCount;
              insertionPos++)
            {
                if (gradientPos < m_pGradientPoints[insertionPos].pos)
                {
                    // We found the array index in which to insert the new gradient point.
                    // Exit now.
                    break;
                }
                else if (gradientPos == m_pGradientPoints[insertionPos].pos)
                {
                    // Each gradient point is required to contain a unique gradient
                    // position, so throw an exception.
                    throw new ArgumentException();
                }
            }
            return insertionPos;
        }


        /// Inserts the gradient point at the specified position in the
        /// internal gradient-point array.
        ///
        /// @param insertionPos The zero-based array position in which to
        /// insert the gradient point.
        /// @param gradientPos The position of this gradient point.
        /// @param gradientColor The color of this gradient point.
        ///
        /// To make room for this new gradient point, this method reallocates
        /// the gradient-point array and shifts all gradient points occurring
        /// after the insertion position up by one.
        ///
        /// Because this object requires that all gradient points in the array
        /// must be sorted by the position, the new gradient point should be
        /// inserted at the position in which the order is still preserved.
        private void InsertAtPos(int insertionPos, double gradientPos, Color gradientColor)
        {
            // Make room for the new gradient point at the specified insertion position
            // within the gradient point array.  The insertion position is determined by
            // the gradient point's position; the gradient points must be sorted by
            // gradient position within that array.
            GradientPoint[] newGradientPoints = new GradientPoint[m_gradientPointCount + 1];
            for (int i = 0; i < m_gradientPointCount; i++)
            {
                if (i < insertionPos)
                {
                    newGradientPoints[i] = m_pGradientPoints[i];
                }
                else
                {
                    newGradientPoints[i + 1] = m_pGradientPoints[i];
                }
            }
            //delete[] m_pGradientPoints;
            m_pGradientPoints = newGradientPoints;
            ++m_gradientPointCount;

            // Now that we've made room for the new gradient point within the array, add
            // the new gradient point.
            m_pGradientPoints[insertionPos].pos = gradientPos;
            m_pGradientPoints[insertionPos].color = gradientColor;
        }


        /// Number of gradient points.
        private int m_gradientPointCount;

        /// Array that stores the gradient points.
        private GradientPoint[] m_pGradientPoints;

        /// A color object that is used by a gradient object to store a
        /// temporary value.
        private Color m_workingColor;
    }



    /// <summary>
    /// Implements a noise map, a 2-dimensional array of floating-point
    /// values.
    ///
    /// A noise map is designed to store coherent-noise values generated by a
    /// noise module, although it can store values from any source.  A noise
    /// map is often used as a terrain height map or a grayscale texture.
    ///
    /// The size (width and height) of the noise map can be specified during
    /// object construction or at any other time.
    ///
    /// The GetValue() and SetValue() methods can be used to access individual
    /// values stored in the noise map.
    ///
    /// This class manages its own memory.  If you copy a noise map object
    /// into another noise map object, the original contents of the noise map
    /// object will be freed.
    ///
    /// If you specify a new size for the noise map and the new size is
    /// smaller than the current size, the allocated memory will not be
    /// reallocated.
    /// Call ReclaimMem() to reclaim the wasted memory.
    ///
    /// <b>Border Values</b>
    ///
    /// All of the values outside of the noise map are assumed to have a
    /// common value known as the <i>border value</i>.
    ///
    /// To set the border value, call the SetBorderValue() method.
    ///
    /// The GetValue() method returns the border value if the specified value
    /// lies outside of the noise map.
    ///
    /// <b>Internal Noise Map Structure</b>
    ///
    /// Internally, the values are organized into horizontal rows called @a
    /// slabs.  Slabs are ordered from bottom to top.
    ///
    /// Each slab contains a contiguous row of values in memory.  The values
    /// in a slab are organized left to right.
    ///
    /// The offset between the starting points of any two adjacent slabs is
    /// called the <i>stride amount</i>.  The stride amount is measured by
    /// the number of @a float values between these two starting points, not
    /// by the number of bytes.  For efficiency reasons, the stride is often a
    /// multiple of the machine word size.
    ///
    /// The GetSlabPtr() and GetConstSlabPtr() methods allow you to retrieve
    /// pointers to the slabs themselves.
    /// </summary>
    public class NoiseMap
    {

        /// The maximum width of a raster.
        public const int RASTER_MAX_WIDTH = 32767;

        /// The maximum height of a raster.
        public const int RASTER_MAX_HEIGHT = 32767;

        // The raster's stride length must be a multiple of this constant.
        public const int RASTER_STRIDE_BOUNDARY = 4;

        /// A pointer to a callback function used by the NoiseMapBuilder class.
        ///
        /// The NoiseMapBuilder::Build() method calls this callback function each
        /// time it fills a row of the noise map with coherent-noise values.
        ///
        /// This callback function has a single integer parameter that contains
        /// a count of the rows that have been completed.  It returns void.  Pass
        /// a function with this signature to the NoiseMapBuilder::SetCallback()
        /// method.
        public delegate void NoiseMapCallback(int row);

        /// Number of meters per point in a Terragen terrain (TER) file.
        const double DEFAULT_METERS_PER_POINT = 30.0;

        /// Same as the DEFAULT_METERS_PER_POINT constant, but for us
        /// canuckleheads.
        const double DEFAULT_METRES_PER_POINT = DEFAULT_METERS_PER_POINT;

        /// Constructor.
        ///
        /// Creates an empty noise map.
        public NoiseMap()
        {
            InitObj();
        }


        /// Constructor.
        ///
        /// @param width The width of the new noise map.
        /// @param height The height of the new noise map.
        ///
        /// @pre The width and height values are positive.
        /// @pre The width and height values do not exceed the maximum
        /// possible width and height for the noise map.
        ///
        /// @throw noise::ExceptionInvalidParam See the preconditions.
        /// @throw noise::ExceptionOutOfMemory Out of memory.
        ///
        /// Creates a noise map with uninitialized values.
        ///
        /// It is considered an error if the specified dimensions are not
        /// positive.
        public NoiseMap(int width, int height)
        {
            InitObj();
            SetSize(width, height);
        }

        /// Clears the noise map to a specified value.
        ///
        /// @param value The value that all positions within the noise map are
        /// cleared to.
        public void Clear(float value)
        {
            if (m_pNoiseMap != null)
            {
                for (int y = 0; y < m_height; y++)
                {
                    for (int x = 0; x < m_width; x++)
                    {
                        m_pNoiseMap[x, y] = value;
                    }
                }
            }
        }


        /// Returns the value used for all positions outside of the noise map.
        ///
        /// @returns The value used for all positions outside of the noise
        /// map.
        ///
        /// All positions outside of the noise map are assumed to have a
        /// common value known as the <i>border value</i>.
        public float BorderValue
        {
            get { return m_borderValue; }
        }

        /// Returns a const pointer to a slab.
        ///
        /// @returns A const pointer to a slab at the position (0, 0), or
        /// @a NULL if the noise map is empty.
        public float[,] Map
        {
            get { return m_pNoiseMap; }
            set
            {
                m_pNoiseMap = value;
                m_width = m_pNoiseMap.GetLength(0);
                m_height = m_pNoiseMap.GetLength(1);
            }
        }

        /// Returns the height of the noise map.
        ///
        /// @returns The height of the noise map.
        public int Height
        {
            get { return m_height; }
        }

        /// Returns the amount of memory allocated for this noise map.
        ///
        /// @returns The amount of memory allocated for this noise map.
        ///
        /// This method returns the number of @a float values allocated.
        public long MemUsed
        {
            get { return m_memUsed; }
        }

        /// Returns a pointer to a value at the specified position.
        ///
        /// @param x The x coordinate of the position.
        /// @param y The y coordinate of the position.
        ///
        /// @returns The value at the position ( @a x, @a y )
        ///
        /// @pre The coordinates must exist within the bounds of the noise
        /// map.
        ///
        /// This method does not perform bounds checking so be careful when
        /// calling it.
        public float this[int x, int y]
        {
            get { return m_pNoiseMap[x, y]; }
            set { m_pNoiseMap[x, y] = value; }
        }

        /// Returns the stride amount of the noise map.
        ///
        /// @returns The stride amount of the noise map.
        ///
        /// - The <i>stride amount</i> is the offset between the starting
        ///   points of any two adjacent slabs in a noise map.
        /// - The stride amount is measured by the number of @a float values
        ///   between these two points, not by the number of bytes.
        public int Stride
        {
            get { return m_stride; }
        }

        /// Returns a value from the specified position in the noise map.
        ///
        /// @param x The x coordinate of the position.
        /// @param y The y coordinate of the position.
        ///
        /// @returns The value at that position.
        ///
        /// This method returns the border value if the coordinates exist
        /// outside of the noise map.
        public float GetValue(int x, int y)
        {
            if (m_pNoiseMap != null)
            {
                if (x >= 0 && x < m_width && y >= 0 && y < m_height)
                {
                    return m_pNoiseMap[x, y];
                }
            }
            // The coordinates specified are outside the noise map.  Return the border
            // value.
            return m_borderValue;
        }

        /// Returns the width of the noise map.
        ///
        /// @returns The width of the noise map.
        public int Width
        {
            get { return m_width; }
        }

        /// Reallocates the noise map to recover wasted memory.
        ///
        /// @throw noise::ExceptionOutOfMemory Out of memory.  (Yes, this
        /// method can return an out-of-memory exception because two noise
        /// maps will temporarily exist in memory during this call.)
        ///
        /// The contents of the noise map is unaffected.
        public void ReclaimMem()
        {
            throw new NotImplementedException();
        }

        /// Sets the value to use for all positions outside of the noise map.
        ///
        /// @param borderValue The value to use for all positions outside of
        /// the noise map.
        ///
        /// All positions outside of the noise map are assumed to have a
        /// common value known as the <i>border value</i>.
        public void SetBorderValue(float borderValue)
        {
            m_borderValue = borderValue;
        }

        /// Sets the new size for the noise map.
        ///
        /// @param width The new width for the noise map.
        /// @param height The new height for the noise map.
        ///
        /// @pre The width and height values are positive.
        /// @pre The width and height values do not exceed the maximum
        /// possible width and height for the noise map.
        ///
        /// @throw noise::ExceptionInvalidParam See the preconditions.
        /// @throw noise::ExceptionOutOfMemory Out of memory.
        ///
        /// On exit, the contents of the noise map are undefined.
        ///
        /// If the @a OUT_OF_MEMORY exception occurs, this noise map object
        /// becomes empty.
        ///
        /// If the @a INVALID_PARAM exception occurs, the noise map is
        /// unmodified.
        public void SetSize(int width, int height)
        {
            if (width < 0 || height < 0
              || width > RASTER_MAX_WIDTH || height > RASTER_MAX_HEIGHT)
            {
                // Invalid width or height.
                throw new ArgumentException();
            }
            else if (width == 0 || height == 0)
            {
                // An empty noise map was specified.  Delete it and zero out the size
                // member variables.
                DeleteNoiseMapAndReset();
            }
            else
            {
                // A new noise map size was specified.  Allocate a new noise map buffer
                // unless the current buffer is large enough for the new noise map (we
                // don't want costly reallocations going on.)
                long newMemUsage = CalcMinMemUsage(width, height);
                if (m_memUsed < newMemUsage)
                {
                    // The new size is too big for the current noise map buffer.  We need to
                    // reallocate.
                    DeleteNoiseMapAndReset();
                    m_pNoiseMap = new float[width, height];

                    m_memUsed = newMemUsage;
                }
                m_stride = (int)CalcStride(width);
                m_width = width;
                m_height = height;
            }
        }

        /// Sets a value at a specified position in the noise map.
        ///
        /// @param x The x coordinate of the position.
        /// @param y The y coordinate of the position.
        /// @param value The value to set at the given position.
        ///
        /// This method does nothing if the noise map object is empty or the
        /// position is outside the bounds of the noise map.
        public void SetValue(int x, int y, float value)
        {
            if (m_pNoiseMap != null)
            {
                if (x >= 0 && x < m_width && y >= 0 && y < m_height)
                {
                    m_pNoiseMap[x, y] = value;
                }
            }
        }
        /// Takes ownership of the buffer within the source noise map.
        ///
        /// @param source The source noise map.
        ///
        /// On exit, the source noise map object becomes empty.
        ///
        /// This method only moves the buffer pointer so this method is very
        /// quick.
        public void TakeOwnership(NoiseMap source)
        {
            throw new NotImplementedException();
        }



        /// Returns the minimum amount of memory required to store a noise map
        /// of the specified size.
        ///
        /// @param width The width of the noise map.
        /// @param height The height of the noise map.
        ///
        /// @returns The minimum amount of memory required to store the noise
        /// map.
        ///
        /// The returned value is measured by the number of @a float values
        /// required to store the noise map, not by the number of bytes.
        private long CalcMinMemUsage(int width, int height)
        {
            return CalcStride(width) * height;
        }

        /// Calculates the stride amount for a noise map.
        ///
        /// @param width The width of the noise map.
        ///
        /// @returns The stride amount.
        ///
        /// - The <i>stride amount</i> is the offset between the starting
        ///   points of any two adjacent slabs in a noise map.
        /// - The stride amount is measured by the number of @a float values
        ///   between these two points, not by the number of bytes.
        private long CalcStride(int width)
        {
            return (long)(((width + RASTER_STRIDE_BOUNDARY - 1)
              / RASTER_STRIDE_BOUNDARY) * RASTER_STRIDE_BOUNDARY);
        }

        /// Copies the contents of the buffer in the source noise map into
        /// this noise map.
        ///
        /// @param source The source noise map.
        ///
        /// @throw noise::ExceptionOutOfMemory Out of memory.
        ///
        /// This method reallocates the buffer in this noise map object if
        /// necessary.
        ///
        /// @warning This method calls the standard library function
        /// @a memcpy, which probably violates the DMCA because it can be used
        //. to make a bitwise copy of anything, like, say, a DVD.  Don't call
        /// this method if you live in the USA.
        private void CopyNoiseMap(NoiseMap source)
        {
            // Resize the noise map buffer, then copy the values from the source noise
            // map buffer to this noise map buffer.
            SetSize(source.Width, source.Height);
            for (int x = 0; x < source.Width; x++)
            {
                for (int y = 0; y < source.Height; y++)
                {
                    this.m_pNoiseMap[x, y] = source.m_pNoiseMap[x, y];
                }
            }
            // Copy the border value as well.
            m_borderValue = source.m_borderValue;
        }

        /// Resets the noise map object.
        ///
        /// This method is similar to the InitObj() method, except this method
        /// deletes the buffer in this noise map.
        private void DeleteNoiseMapAndReset()
        {
            m_pNoiseMap = null;
            InitObj();
        }

        /// Initializes the noise map object.
        ///
        /// @pre Must be called during object construction.
        /// @pre The noise map buffer must not exist.
        private void InitObj()
        {
            m_pNoiseMap = null;
            m_height = 0;
            m_width = 0;
            m_stride = 0;
            m_memUsed = 0;
            m_borderValue = 0.0f;
        }

        /// Value used for all positions outside of the noise map.
        private float m_borderValue;

        /// The current height of the noise map.
        private int m_height;

        /// The amount of memory allocated for this noise map.
        ///
        /// This value is equal to the number of @a float values allocated for
        /// the noise map, not the number of bytes.
        private long m_memUsed;

        /// A pointer to the noise map buffer.
        private float[,] m_pNoiseMap;

        /// The stride amount of the noise map.
        private int m_stride;

        /// The current width of the noise map.
        private int m_width;
    }

    /// Implements an image, a 2-dimensional array of color values.
    ///
    /// An image can be used to store a color texture.
    ///
    /// These color values are of type Color.
    ///
    /// The size (width and height) of the image can be specified during
    /// object construction or at any other time.
    ///
    /// The GetValue() and SetValue() methods can be used to access individual
    /// color values stored in the image.
    ///
    /// This class manages its own memory.  If you copy an image object into
    /// another image object, the original contents of the image object will
    /// be freed.
    ///
    /// If you specify a new size for the image and the new size is smaller
    /// than the current size, the allocated memory will not be reallocated.
    /// Call ReclaimMem() to reclaim the wasted memory.
    ///
    /// <b>Border Values</b>
    ///
    /// All of the color values outside of the image are assumed to have a
    /// common color value known as the <i>border value</i>.
    ///
    /// To set the border value, call the SetBorderValue() method.
    ///
    /// The GetValue() method returns the border value if the specified
    /// position lies outside of the image.
    ///
    /// <b>Internal Image Structure</b>
    ///
    /// Internally, the color values are organized into horizontal rows called
    /// @a slabs.  Slabs are ordered from bottom to top.
    ///
    /// Each slab contains a contiguous row of color values in memory.  The
    /// color values in a slab are organized left to right.  These values are
    /// of type Color.
    ///
    /// The offset between the starting points of any two adjacent slabs is
    /// called the <i>stride amount</i>.  The stride amount is measured by the
    /// number of Color objects between these two starting points, not by the
    /// number of bytes.  For efficiency reasons, the stride is often a
    /// multiple of the machine word size.
    ///
    /// The GetSlabPtr() methods allow you to retrieve pointers to the slabs
    /// themselves.
    public class NoiseImage
    {
        /// Constructor.
        ///
        /// Creates an empty image.
        public NoiseImage()
        {
            InitObj();
        }

        /// Constructor.
        ///
        /// @param width The width of the new image.
        /// @param height The height of the new image.
        ///
        /// @pre The width and height values are positive.
        /// @pre The width and height values do not exceed the maximum
        /// possible width and height for the image.
        ///
        /// @throw noise::ExceptionInvalidParam See the preconditions.
        /// @throw noise::ExceptionOutOfMemory Out of memory.
        ///
        /// Creates an image with uninitialized color values.
        ///
        /// It is considered an error if the specified dimensions are not
        /// positive.
        public NoiseImage(int width, int height)
        {
            InitObj();
            SetSize(width, height);
        }

        /// Clears the image to a specified color value.
        ///
        /// @param value The color value that all positions within the image
        /// are cleared to.
        public void Clear(Color value)
        {
            if (m_pImage != null)
            {
                for (int y = 0; y < m_height; y++)
                {
                    for (int x = 0; x < m_width; x++)
                    {
                        this[x, y] = value;
                    }
                }
            }
        }

        /// Returns the color value used for all positions outside of the
        /// image.
        ///
        /// @returns The color value used for all positions outside of the
        /// image.
        ///
        /// All positions outside of the image are assumed to have a common
        /// color value known as the <i>border value</i>.
        public Color GetBorderValue()
        {
            return m_borderValue;
        }

        /// Returns a const pointer to a slab at the specified position.
        ///
        /// @param x The x coordinate of the position.
        /// @param y The y coordinate of the position.
        ///
        /// @returns A const pointer to a slab at the position ( @a x, @a y ),
        /// or @a NULL if the image is empty.
        ///
        /// @pre The coordinates must exist within the bounds of the image.
        ///
        /// This method does not perform bounds checking so be careful when
        /// calling it.
        public Color this[int x, int y]
        {
            get { return m_pImage[x, y]; }
            set
            {
                m_pImage[x, y] = value;
            }
        }

        /// Returns the height of the image.
        ///
        /// @returns The height of the image.
        public int Height
        {
            get { return m_height; }
        }

        /// Returns the amount of memory allocated for this image.
        ///
        /// @returns The amount of memory allocated for this image.
        ///
        /// This method returns the number of Color objects allocated.
        public long GetMemUsed()
        {
            return m_memUsed;
        }

        /// Returns the stride amount of the image.
        ///
        /// @returns The stride amount of the image.
        ///
        /// - The <i>stride amount</i> is the offset between the starting
        ///   points of any two adjacent slabs in an image.
        /// - The stride amount is measured by the number of Color objects
        ///   between these two points, not by the number of bytes.
        public int GetStride()
        {
            return m_stride;
        }

        /// Returns a color value from the specified position in the image.
        ///
        /// @param x The x coordinate of the position.
        /// @param y The y coordinate of the position.
        ///
        /// @returns The color value at that position.
        ///
        /// This method returns the border value if the coordinates exist
        /// outside of the image.
        public Color GetValue(int x, int y)
        {
            return this[x, y];
        }

        /// Returns the width of the image.
        ///
        /// @returns The width of the image.
        public int Width
        {
            get { return m_width; }
        }

        /// Reallocates the image to recover wasted memory.
        ///
        /// @throw noise::ExceptionOutOfMemory Out of memory.  (Yes, this
        /// method can return an out-of-memory exception because two images
        /// will exist temporarily in memory during this call.)
        ///
        /// The contents of the image is unaffected.
        public void ReclaimMem()
        {
            throw new NotImplementedException();
        }

        /// Sets the color value to use for all positions outside of the
        /// image.
        ///
        /// @param borderValue The color value to use for all positions
        /// outside of the image.
        ///
        /// All positions outside of the image are assumed to have a common
        /// color value known as the <i>border value</i>.
        public void SetBorderValue(Color borderValue)
        {
            m_borderValue = borderValue;
        }

        /// Sets the new size for the image.
        ///
        /// @param width The new width for the image.
        /// @param height The new height for the image.
        ///
        /// @pre The width and height values are positive.
        /// @pre The width and height values do not exceed the maximum
        /// possible width and height for the image.
        ///
        /// @throw noise::ExceptionInvalidParam See the preconditions.
        /// @throw noise::ExceptionOutOfMemory Out of memory.
        ///
        /// On exit, the contents of the image are undefined.
        ///
        /// If the @a OUT_OF_MEMORY exception occurs, this image becomes
        /// empty.
        ///
        /// If the @a INVALID_PARAM exception occurs, the image is unmodified.
        public void SetSize(int width, int height)
        {
            if (width < 0 || height < 0
              || width > NoiseMap.RASTER_MAX_WIDTH || height > NoiseMap.RASTER_MAX_HEIGHT)
            {
                // Invalid width or height.
                throw new ArgumentException();
            }
            else if (width == 0 || height == 0)
            {
                // An empty image was specified.  Delete it and zero out the size member
                // variables.
                DeleteImageAndReset();
            }
            else
            {
                // A new image size was specified.  Allocate a new image buffer unless
                // the current buffer is large enough for the new image (we don't want
                // costly reallocations going on.)
                long newMemUsage = CalcMinMemUsage(width, height);
                if (m_memUsed < newMemUsage)
                {
                    // The new size is too big for the current image buffer.  We need to
                    // reallocate.
                    DeleteImageAndReset();
                    m_pImage = new Color[width, height];

                    m_memUsed = newMemUsage;
                }
                m_stride = (int)CalcStride(width);
                m_width = width;
                m_height = height;
            }
        }

        /// Sets a color value at a specified position in the image.
        ///
        /// @param x The x coordinate of the position.
        /// @param y The y coordinate of the position.
        /// @param value The color value to set at the given position.
        ///
        /// This method does nothing if the image is empty or the position is
        /// outside the bounds of the image.
        public void SetValue(int x, int y, Color value)
        {
            this[x, y] = value;
        }

        /// Takes ownership of the buffer within the source image.
        ///
        /// @param source The source image.
        ///
        /// On exit, the source image object becomes empty.
        ///
        /// This method only moves the buffer pointer so this method is very
        /// quick.
        public void TakeOwnership(NoiseImage source)
        {
            throw new NotImplementedException();
        }



        /// Returns the minimum amount of memory required to store an image of
        /// the specified size.
        ///
        /// @param width The width of the image.
        /// @param height The height of the image.
        ///
        /// @returns The minimum amount of memory required to store the image.
        ///
        /// The returned color value is measured by the number of Color
        /// objects required to store the image, not by the number of bytes.
        private long CalcMinMemUsage(int width, int height)
        {
            return CalcStride(width) * (long)height;
        }

        /// Calculates the stride amount for an image.
        ///
        /// @param width The width of the image.
        ///
        /// @returns The stride amount.
        ///
        /// - The <i>stride amount</i> is the offset between the starting
        ///   points of any two adjacent slabs in an image.
        /// - The stride amount is measured by the number of Color objects
        ///   between these two points, not by the number of bytes.
        private long CalcStride(int width)
        {
            return (long)(((width + NoiseMap.RASTER_STRIDE_BOUNDARY - 1)
            / NoiseMap.RASTER_STRIDE_BOUNDARY) * NoiseMap.RASTER_STRIDE_BOUNDARY);
        }

        /// Copies the contents of the buffer in the source image into this
        /// image.
        ///
        /// @param source The source image.
        ///
        /// @throw noise::ExceptionOutOfMemory Out of memory.
        ///
        /// This method reallocates the buffer in this image object if
        /// necessary.
        ///
        /// @warning This method calls the standard library function
        /// @a memcpy, which probably violates the DMCA because it can be used
        /// to make a bitwise copy of anything, like, say, a DVD.  Don't call
        /// this method if you live in the USA.
        private void CopyImage(NoiseImage source)
        {
            // Resize the image buffer, then copy the slabs from the source image
            // buffer to this image buffer.
            SetSize(source.Width, source.Height);
            for (int x = 0; x < source.Width; x++)
            {
                for (int y = 0; y < source.Height; y++)
                {
                    this[x, y] = source[x, y];
                }
            }
            // Copy the border value as well.
            m_borderValue = source.m_borderValue;
        }

        /// Resets the image object.
        ///
        /// This method is similar to the InitObj() method, except this method
        /// deletes the memory allocated to the image.
        private void DeleteImageAndReset()
        {
            m_pImage = null;
            InitObj();
        }

        /// Initializes the image object.
        ///
        /// @pre Must be called during object construction.
        /// @pre The image buffer must not exist.
        private void InitObj()
        {
            m_pImage = null;
            m_height = 0;
            m_width = 0;
            m_stride = 0;
            m_memUsed = 0;
            m_borderValue = new Color(0, 0, 0, 0);
        }


        /// The Color value used for all positions outside of the image.
        private Color m_borderValue;

        /// The current height of the image.
        private int m_height;

        /// The amount of memory allocated for the image.
        ///
        /// This value is equal to the number of Color objects allocated for
        /// the image, not the number of bytes.
        private long m_memUsed;

        /// A pointer to the image buffer.
        private Color[,] m_pImage;

        /// The stride amount of the image.
        private int m_stride;

        /// The current width of the image.
        private int m_width;

    }


    /// Windows bitmap image writer class.
    ///
    /// This class creates a file in Windows bitmap (*.bmp) format given the
    /// contents of an image object.
    ///
    /// <b>Writing the image</b>
    ///
    /// To write the image to a file, perform the following steps:
    /// - Pass the filename to the SetDestFilename() method.
    /// - Pass an Image object to the SetSourceImage() method.
    /// - Call the WriteDestFile() method.
    ///
    /// The SetDestFilename() and SetSourceImage() methods must be called
    /// before calling the WriteDestFile() method.
    public class WriterBMP
    {
        /// Constructor.
        public WriterBMP()
        {
            m_pSourceImage = null;
        }

        /// Returns the name of the file to write.
        ///
        /// @returns The name of the file to write.
        public string GetDestFilename()
        {
            return m_destFilename;
        }

        /// Sets the name of the file to write.
        ///
        /// @param filename The name of the file to write.
        ///
        /// Call this method before calling the WriteDestFile() method.
        public void SetDestFilename(string filename)
        {
            m_destFilename = filename;
        }

        /// Sets the image object that is written to the file.
        ///
        /// @param sourceImage The image object to write.
        ///
        /// This object only stores a pointer to an image object, so make sure
        /// this object exists before calling the WriteDestFile() method.
        public void SetSourceImage(NoiseImage sourceImage)
        {
            m_pSourceImage = sourceImage;
        }

        /// Writes the contents of the image object to the file.
        ///
        /// @pre SetDestFilename() has been previously called.
        /// @pre SetSourceImage() has been previously called.
        ///
        /// @throw noise::ExceptionInvalidParam See the preconditions.
        /// @throw noise::ExceptionOutOfMemory Out of memory.
        /// @throw noise::ExceptionUnknown An unknown exception occurred.
        /// Possibly the file could not be written.
        ///
        /// This method encodes the contents of the image and writes it to a
        /// file.  Before calling this method, call the SetSourceImage()
        /// method to specify the image, then call the SetDestFilename()
        /// method to specify the name of the file to write.
        public void WriteDestFile()
        {
            //Here create the Bitmap to the know height, width and format
            Bitmap bmp = new Bitmap(m_pSourceImage.Width, m_pSourceImage.Height, PixelFormat.Format32bppArgb);
            //First Create the instance of Stopwatch Class
            Stopwatch sw = new Stopwatch();

            // Start The StopWatch ...From 000
            sw.Start();
            // get source bitmap pixel format size
            int Depth = System.Drawing.Bitmap.GetPixelFormatSize(bmp.PixelFormat) / 8;
            byte[] data = new byte[m_pSourceImage.Width * m_pSourceImage.Height * Depth];


            for (int x = 0; x < m_pSourceImage.Width; x++)
                for (int y = 0; y < m_pSourceImage.Height; y++)
                {
                    // Get start index of the specified pixel
                    int i = ((y * m_pSourceImage.Width) + x) * Depth;
                    Color sColor = m_pSourceImage[x, y];
                    data[i + 3] = sColor.alpha;
                    data[i + 2] = sColor.red;
                    data[i + 1] = sColor.green;
                    data[i + 0] = sColor.blue;
                }

            //Create a BitmapData and Lock all pixels to be written 
            BitmapData bmpData = bmp.LockBits(
                                 new Rectangle(0, 0, bmp.Width, bmp.Height),
                                 ImageLockMode.WriteOnly, bmp.PixelFormat);

            //Copy the data from the byte array into BitmapData.Scan0
            Marshal.Copy(data, 0, bmpData.Scan0, data.Length);

            //Unlock the pixels
            bmp.UnlockBits(bmpData);
            bmp.Save(m_destFilename);
            sw.Stop();
            //Writing Execution Time
            string ExecutionTimeTaken = string.Format("Minutes :{0}\tSeconds :{1}\t Mili seconds :{2}", sw.Elapsed.Minutes, sw.Elapsed.Seconds, sw.Elapsed.TotalMilliseconds);
            Debug.WriteLine("WriterBMP: " + ExecutionTimeTaken);
        }



        /// Calculates the width of one horizontal line in the file, in bytes.
        ///
        /// @param width The width of the image, in points.
        ///
        /// @returns The width of one horizontal line in the file.
        ///
        /// Windows bitmap files require that the width of one horizontal line
        /// must be aligned to a 32-bit boundary.
        protected int CalcWidthByteCount(int width)
        {
            return ((width * 3) + 3) & ~0x03;
        }


        /// Name of the file to write.
        protected string m_destFilename;

        /// A pointer to the image object that will be written to the file.
        protected NoiseImage m_pSourceImage;
    }

#if TODO
    /// Terragen Terrain writer class.
    ///
    /// This class creates a file in Terrage Terrain (*.ter) format given the
    /// contents of a noise map object.  This class treats the values in the
    /// noise map as elevations measured in meters.
    ///
    /// <a href=http://www.planetside.co.uk/terragen/>Terragen</a> is a
    /// terrain application that renders realistic landscapes.  Terragen is
    /// available for Windows and MacOS; unfortunately, Terragen does not have
    /// UN*X versions.
    ///
    /// <b>Writing the noise map</b>
    ///
    /// To write the noise map, perform the following steps:
    /// - Pass the filename to the SetDestFilename() method.
    /// - Pass a NoiseMap object to the SetSourceNoiseMap() method.
    /// - Call the WriteDestFile() method.
    ///
    /// The SetDestFilename() and SetSourceNoiseMap() methods must be called
    /// before calling the WriteDestFile() method.
    class WriterTER
    {

      public:

        /// Constructor.
        WriterTER ():
          m_pSourceNoiseMap (NULL),
          m_metersPerPoint (DEFAULT_METERS_PER_POINT)
        {
        }

        /// Returns the name of the file to write.
        ///
        /// @returns The name of the file to write.
        std::string GetDestFilename () const
        {
          return m_destFilename;
        }

        /// Returns the distance separating adjacent points in the noise map,
        /// in meters.
        ///
        /// @returns The distance separating adjacent points in the noise map.
        float GetMetersPerPoint () const
        {
          return m_metersPerPoint;
        }

        /// Sets the name of the file to write.
        ///
        /// @param filename The name of the file to write.
        ///
        /// Call this method before calling the WriteDestFile() method.
        void SetDestFilename (const std::string& filename)
        {
          m_destFilename = filename;
        }

        /// Sets the distance separating adjacent points in the noise map, in
        /// meters.
        ///
        /// @param metersPerPoint The distance separating adjacent points in
        /// the noise map.
        void SetMetersPerPoint (float metersPerPoint)
        {
          m_metersPerPoint = metersPerPoint;
        }

        /// Sets the noise map object that is written to the file.
        ///
        /// @param sourceNoiseMap The noise map object to write.
        ///
        /// This object only stores a pointer to a noise map object, so make
        /// sure this object exists before calling the WriteDestFile() method.
        void SetSourceNoiseMap (NoiseMap& sourceNoiseMap)
        {
          m_pSourceNoiseMap = &sourceNoiseMap;
        }

        /// Writes the contents of the noise map object to the file.
        ///
        /// @pre SetDestFilename() has been previously called.
        /// @pre SetSourceNoiseMap() has been previously called.
        ///
        /// @throw noise::ExceptionInvalidParam See the preconditions.
        /// @throw noise::ExceptionOutOfMemory Out of memory.
        /// @throw noise::ExceptionUnknown An unknown exception occurred.
        /// Possibly the file could not be written.
        ///
        /// This method encodes the contents of the noise map and writes it to
        /// a file.  Before calling this method, call the SetSourceNoiseMap()
        /// method to specify the noise map, then call the SetDestFilename()
        /// method to specify the name of the file to write.
        ///
        /// This object assumes that the noise values represent elevations in
        /// meters.
        void WriteDestFile ();

      protected:
    
        /// Calculates the width of one horizontal line in the file, in bytes.
        ///
        /// @param width The width of the noise map, in points.
        ///
        /// @returns The width of one horizontal line in the file.
        int CalcWidthByteCount (int width) const;

        /// Name of the file to write.
        std::string m_destFilename;

        /// The distance separating adjacent points in the noise map, in
        /// meters.
        float m_metersPerPoint;

        /// A pointer to the noise map that will be written to the file.
        NoiseMap* m_pSourceNoiseMap;

    }
#endif

    /// Abstract base class for a noise-map builder
    ///
    /// A builder class builds a noise map by filling it with coherent-noise
    /// values generated from the surface of a three-dimensional mathematical
    /// object.  Each builder class defines a specific three-dimensional
    /// surface, such as a cylinder, sphere, or plane.
    ///
    /// A builder class describes these input values using a coordinate system
    /// applicable for the mathematical object (e.g., a latitude/longitude
    /// coordinate system for the spherical noise-map builder.)  It then
    /// "flattens" these coordinates onto a plane so that it can write the
    /// coherent-noise values into a two-dimensional noise map.
    ///
    /// <b>Building the Noise Map</b>
    ///
    /// To build the noise map, perform the following steps:
    /// - Pass the bounding coordinates to the SetBounds() method.
    /// - Pass the noise map size, in points, to the SetDestSize() method.
    /// - Pass a NoiseMap object to the SetDestNoiseMap() method.
    /// - Pass a noise module (derived from noise::module::Module) to the
    ///   SetSourceModule() method.
    /// - Call the Build() method.
    ///
    /// You may also pass a callback function to the SetCallback() method.
    /// The Build() method calls this callback function each time it fills a
    /// row of the noise map with coherent-noise values.  This callback
    /// function has a single integer parameter that contains a count of the
    /// rows that have been completed.  It returns void.
    ///
    /// Note that SetBounds() is not defined in the abstract base class; it is
    /// only defined in the derived classes.  This is because each model uses
    /// a different coordinate system.
    public abstract class NoiseMapBuilder
    {
        /// Constructor.
        public NoiseMapBuilder()
        {
            m_pCallback = null;
            m_destHeight = 0;
            m_destWidth = 0;
            m_pDestNoiseMap = null;
            m_pSourceModule = null;
        }

        /// Builds the noise map.
        ///
        /// @pre SetBounds() was previously called.
        /// @pre SetDestNoiseMap() was previously called.
        /// @pre SetSourceModule() was previously called.
        /// @pre The width and height values specified by SetDestSize() are
        /// positive.
        /// @pre The width and height values specified by SetDestSize() do not
        /// exceed the maximum possible width and height for the noise map.
        ///
        /// @post The original contents of the destination noise map is
        /// destroyed.
        ///
        /// @throw noise::ExceptionInvalidParam See the preconditions.
        /// @throw noise::ExceptionOutOfMemory Out of memory.
        ///
        /// If this method is successful, the destination noise map contains
        /// the coherent-noise values from the noise module specified by
        /// SetSourceModule().
        public abstract void Build();

        /// Returns the height of the destination noise map.
        ///
        /// @returns The height of the destination noise map, in points.
        ///
        /// This object does not change the height in the destination noise
        /// map object until the Build() method is called.
        public double GetDestHeight()
        {
            return m_destHeight;
        }

        /// Returns the width of the destination noise map.
        ///
        /// @returns The width of the destination noise map, in points.
        ///
        /// This object does not change the height in the destination noise
        /// map object until the Build() method is called.
        public double GetDestWidth()
        {
            return m_destWidth;
        }

        /// Sets the callback function that Build() calls each time it fills a
        /// row of the noise map with coherent-noise values.
        ///
        /// @param pCallback The callback function.
        ///
        /// This callback function has a single integer parameter that
        /// contains a count of the rows that have been completed.  It returns
        /// void.  Pass a function with this signature to the SetCallback()
        /// method.
        public void SetCallback(NoiseMap.NoiseMapCallback pCallback)
        {
            m_pCallback = pCallback;
        }

        /// Sets the destination noise map.
        ///
        /// @param destNoiseMap The destination noise map.
        ///
        /// The destination noise map will contain the coherent-noise values
        /// from this noise map after a successful call to the Build() method.
        ///
        /// The destination noise map must exist throughout the lifetime of
        /// this object unless another noise map replaces that noise map.
        public void SetDestNoiseMap(NoiseMap destNoiseMap)
        {
            m_pDestNoiseMap = destNoiseMap;
        }

        /// Sets the source module.
        ///
        /// @param sourceModule The source module.
        ///
        /// This object fills in a noise map with the coherent-noise values
        /// from this source module.
        ///
        /// The source module must exist throughout the lifetime of this
        /// object unless another noise module replaces that noise module.
        public void SetSourceModule(ModuleBase sourceModule)
        {
            m_pSourceModule = sourceModule;
        }

        /// Sets the size of the destination noise map.
        ///
        /// @param destWidth The width of the destination noise map, in
        /// points.
        /// @param destHeight The height of the destination noise map, in
        /// points.
        ///
        /// This method does not change the size of the destination noise map
        /// until the Build() method is called.
        public void SetDestSize(int destWidth, int destHeight)
        {
            m_destWidth = destWidth;
            m_destHeight = destHeight;
        }

        /// The callback function that Build() calls each time it fills a row
        /// of the noise map with coherent-noise values.
        ///
        /// This callback function has a single integer parameter that
        /// contains a count of the rows that have been completed.  It returns
        /// void.  Pass a function with this signature to the SetCallback()
        /// method.
        protected NoiseMap.NoiseMapCallback m_pCallback;

        /// Height of the destination noise map, in points.
        protected int m_destHeight;

        /// Width of the destination noise map, in points.
        protected int m_destWidth;

        /// Destination noise map that will contain the coherent-noise values.
        protected NoiseMap m_pDestNoiseMap;

        /// Source noise module that will generate the coherent-noise values.
        protected ModuleBase m_pSourceModule;
    }

    /// Builds a cylindrical noise map.
    ///
    /// This class builds a noise map by filling it with coherent-noise values
    /// generated from the surface of a cylinder.
    ///
    /// This class describes these input values using an (angle, height)
    /// coordinate system.  After generating the coherent-noise value from the
    /// input value, it then "flattens" these coordinates onto a plane so that
    /// it can write the values into a two-dimensional noise map.
    ///
    /// The cylinder model has a radius of 1.0 unit and has infinite height.
    /// The cylinder is oriented along the @a y axis.  Its center is at the
    /// origin.
    ///
    /// The x coordinate in the noise map represents the angle around the
    /// cylinder's y axis.  The y coordinate in the noise map represents the
    /// height above the x-z plane.
    ///
    /// The application must provide the lower and upper angle bounds of the
    /// noise map, in degrees, and the lower and upper height bounds of the
    /// noise map, in units.
    public class NoiseMapBuilderCylinder : NoiseMapBuilder
    {
        /// Constructor.
        public NoiseMapBuilderCylinder()
        {
            m_lowerAngleBound = 0.0;
            m_lowerHeightBound = 0.0;
            m_upperAngleBound = 0.0;
            m_upperHeightBound = 0.0;
        }

        public override void Build()
        {
            if (m_upperAngleBound <= m_lowerAngleBound
              || m_upperHeightBound <= m_lowerHeightBound
              || m_destWidth <= 0
              || m_destHeight <= 0
              || m_pSourceModule == null
              || m_pDestNoiseMap == null)
            {
                throw new ArgumentException();
            }

            // Resize the destination noise map so that it can store the new output
            // values from the source model.
            m_pDestNoiseMap.SetSize(m_destWidth, m_destHeight);

            // Create the cylinder model.
            Cylinder cylinderModel = new Cylinder();
            cylinderModel.SetModule(m_pSourceModule);

            double angleExtent = m_upperAngleBound - m_lowerAngleBound;
            double heightExtent = m_upperHeightBound - m_lowerHeightBound;
            double xDelta = angleExtent / (double)m_destWidth;
            double yDelta = heightExtent / (double)m_destHeight;
            double curAngle = m_lowerAngleBound;
            double curHeight = m_lowerHeightBound;

            // Fill every point in the noise map with the output values from the model.
            for (int y = 0; y < m_destHeight; y++)
            {
                curAngle = m_lowerAngleBound;
                for (int x = 0; x < m_destWidth; x++)
                {
                    float curValue = (float)cylinderModel.GetValue(curAngle, curHeight);
                    m_pDestNoiseMap[x, y] = curValue;
                    curAngle += xDelta;
                }
                curHeight += yDelta;
                if (m_pCallback != null)
                {
                    m_pCallback(y);
                }
            }
        }


        /// Returns the lower angle boundary of the cylindrical noise map.
        ///
        /// @returns The lower angle boundary of the noise map, in degrees.
        public double GetLowerAngleBound()
        {
            return m_lowerAngleBound;
        }

        /// Returns the lower height boundary of the cylindrical noise map.
        ///
        /// @returns The lower height boundary of the noise map, in units.
        ///
        /// One unit is equal to the radius of the cylinder.
        public double GetLowerHeightBound()
        {
            return m_lowerHeightBound;
        }

        /// Returns the upper angle boundary of the cylindrical noise map.
        ///
        /// @returns The upper angle boundary of the noise map, in degrees.
        public double GetUpperAngleBound()
        {
            return m_upperAngleBound;
        }

        /// Returns the upper height boundary of the cylindrical noise map.
        ///
        /// @returns The upper height boundary of the noise map, in units.
        ///
        /// One unit is equal to the radius of the cylinder.
        public double GetUpperHeightBound()
        {
            return m_upperHeightBound;
        }

        /// Sets the coordinate boundaries of the noise map.
        ///
        /// @param lowerAngleBound The lower angle boundary of the noise map,
        /// in degrees.
        /// @param upperAngleBound The upper angle boundary of the noise map,
        /// in degrees.
        /// @param lowerHeightBound The lower height boundary of the noise
        /// map, in units.
        /// @param upperHeightBound The upper height boundary of the noise
        /// map, in units.
        ///
        /// @pre The lower angle boundary is less than the upper angle
        /// boundary.
        /// @pre The lower height boundary is less than the upper height
        /// boundary.
        ///
        /// @throw noise::ExceptionInvalidParam See the preconditions.
        ///
        /// One unit is equal to the radius of the cylinder.
        public void SetBounds(double lowerAngleBound, double upperAngleBound,
          double lowerHeightBound, double upperHeightBound)
        {
            if (lowerAngleBound >= upperAngleBound
              || lowerHeightBound >= upperHeightBound)
            {
                throw new ArgumentException();
            }

            m_lowerAngleBound = lowerAngleBound;
            m_upperAngleBound = upperAngleBound;
            m_lowerHeightBound = lowerHeightBound;
            m_upperHeightBound = upperHeightBound;
        }



        /// Lower angle boundary of the cylindrical noise map, in degrees.
        private double m_lowerAngleBound;

        /// Lower height boundary of the cylindrical noise map, in units.
        private double m_lowerHeightBound;

        /// Upper angle boundary of the cylindrical noise map, in degrees.
        private double m_upperAngleBound;

        /// Upper height boundary of the cylindrical noise map, in units.
        private double m_upperHeightBound;

    }


    /// Builds a planar noise map.
    ///
    /// This class builds a noise map by filling it with coherent-noise values
    /// generated from the surface of a plane.
    ///
    /// This class describes these input values using (x, z) coordinates.
    /// Their y coordinates are always 0.0.
    ///
    /// The application must provide the lower and upper x coordinate bounds
    /// of the noise map, in units, and the lower and upper z coordinate
    /// bounds of the noise map, in units.
    ///
    /// To make a tileable noise map with no seams at the edges, call the
    /// EnableSeamless() method.
    public class NoiseMapBuilderPlane : NoiseMapBuilder
    {
        /// Constructor.
        public NoiseMapBuilderPlane()
        {
            m_isSeamlessEnabled = false;
            m_lowerXBound = 0.0f;
            m_lowerZBound = 0.0f;
            m_upperXBound = 0.0f;
            m_upperZBound = 0.0f;

        }


        public override void Build()
        {
            if (m_upperXBound <= m_lowerXBound
              || m_upperZBound <= m_lowerZBound
              || m_destWidth <= 0
              || m_destHeight <= 0
              || m_pSourceModule == null
              || m_pDestNoiseMap == null)
            {
                throw new ArgumentException();
            }
            // Resize the destination noise map so that it can store the new output
            // values from the source model.
            m_pDestNoiseMap.SetSize(m_destWidth, m_destHeight);

            // Create the plane model.
            Plane planeModel = new Plane();
            planeModel.SetModule(m_pSourceModule);

            double xExtent = m_upperXBound - m_lowerXBound;
            double zExtent = m_upperZBound - m_lowerZBound;
            double xDelta = xExtent / (double)m_destWidth;
            double zDelta = zExtent / (double)m_destHeight;
            double xCur = m_lowerXBound;
            double zCur = m_lowerZBound;

            // Fill every point in the noise map with the output values from the model.
            for (int z = 0; z < m_destHeight; z++)
            {
                xCur = m_lowerXBound;
                for (int x = 0; x < m_destWidth; x++)
                {
                    float finalValue;
                    if (!m_isSeamlessEnabled)
                    {
                        finalValue = (float)planeModel.GetValue(xCur, zCur);
                    }
                    else
                    {
                        double swValue, seValue, nwValue, neValue;
                        swValue = planeModel.GetValue(xCur, zCur);
                        seValue = planeModel.GetValue(xCur + xExtent, zCur);
                        nwValue = planeModel.GetValue(xCur, zCur + zExtent);
                        neValue = planeModel.GetValue(xCur + xExtent, zCur + zExtent);
                        double xBlend = 1.0 - ((xCur - m_lowerXBound) / xExtent);
                        double zBlend = 1.0 - ((zCur - m_lowerZBound) / zExtent);
                        double z0 = Utils.InterpolateLinear(swValue, seValue, xBlend);
                        double z1 = Utils.InterpolateLinear(nwValue, neValue, xBlend);
                        finalValue = (float)Utils.InterpolateLinear(z0, z1, zBlend);
                    }
                    m_pDestNoiseMap[x, z] = finalValue;
                    xCur += xDelta;
                }
                zCur += zDelta;
                if (m_pCallback != null)
                {
                    m_pCallback(z);
                }
            }
        }


        /// Enables or disables seamless tiling.
        ///
        /// @param enable A flag that enables or disables seamless tiling.
        ///
        /// Enabling seamless tiling builds a noise map with no seams at the
        /// edges.  This allows the noise map to be tileable.
        public void EnableSeamless(bool enable = true)
        {
            m_isSeamlessEnabled = enable;
        }

        /// Returns the lower x boundary of the planar noise map.
        ///
        /// @returns The lower x boundary of the planar noise map, in units.
        public double GetLowerXBound()
        {
            return m_lowerXBound;
        }

        /// Returns the lower z boundary of the planar noise map.
        ///
        /// @returns The lower z boundary of the noise map, in units.
        public double GetLowerZBound()
        {
            return m_lowerZBound;
        }

        /// Returns the upper x boundary of the planar noise map.
        ///
        /// @returns The upper x boundary of the noise map, in units.
        public double GetUpperXBound()
        {
            return m_upperXBound;
        }

        /// Returns the upper z boundary of the planar noise map.
        ///
        /// @returns The upper z boundary of the noise map, in units.
        public double GetUpperZBound()
        {
            return m_upperZBound;
        }

        /// Determines if seamless tiling is enabled.
        ///
        /// @returns
        /// - @a true if seamless tiling is enabled.
        /// - @a false if seamless tiling is disabled.
        ///
        /// Enabling seamless tiling builds a noise map with no seams at the
        /// edges.  This allows the noise map to be tileable.
        public bool IsSeamlessEnabled()
        {
            return m_isSeamlessEnabled;
        }

        /// Sets the boundaries of the planar noise map.
        ///
        /// @param lowerXBound The lower x boundary of the noise map, in
        /// units.
        /// @param upperXBound The upper x boundary of the noise map, in
        /// units.
        /// @param lowerZBound The lower z boundary of the noise map, in
        /// units.
        /// @param upperZBound The upper z boundary of the noise map, in
        /// units.
        ///
        /// @pre The lower x boundary is less than the upper x boundary.
        /// @pre The lower z boundary is less than the upper z boundary.
        ///
        /// @throw noise::ExceptionInvalidParam See the preconditions.
        public void SetBounds(double lowerXBound, double upperXBound,
          double lowerZBound, double upperZBound)
        {
            if (lowerXBound >= upperXBound
              || lowerZBound >= upperZBound)
            {
                throw new ArgumentException();
            }

            m_lowerXBound = lowerXBound;
            m_upperXBound = upperXBound;
            m_lowerZBound = lowerZBound;
            m_upperZBound = upperZBound;
        }



        /// A flag specifying whether seamless tiling is enabled.
        private bool m_isSeamlessEnabled;

        /// Lower x boundary of the planar noise map, in units.
        private double m_lowerXBound;

        /// Lower z boundary of the planar noise map, in units.
        private double m_lowerZBound;

        /// Upper x boundary of the planar noise map, in units.
        private double m_upperXBound;

        /// Upper z boundary of the planar noise map, in units.
        private double m_upperZBound;

    }

    /// Builds a spherical noise map.
    ///
    /// This class builds a noise map by filling it with coherent-noise values
    /// generated from the surface of a sphere.
    ///
    /// This class describes these input values using a (latitude, longitude)
    /// coordinate system.  After generating the coherent-noise value from the
    /// input value, it then "flattens" these coordinates onto a plane so that
    /// it can write the values into a two-dimensional noise map.
    ///
    /// The sphere model has a radius of 1.0 unit.  Its center is at the
    /// origin.
    ///
    /// The x coordinate in the noise map represents the longitude.  The y
    /// coordinate in the noise map represents the latitude.  
    ///
    /// The application must provide the southern, northern, western, and
    /// eastern bounds of the noise map, in degrees.
    public class NoiseMapBuilderSphere : NoiseMapBuilder
    {

        /// Constructor.
        public NoiseMapBuilderSphere()
        {
            m_eastLonBound = 0.0;
            m_northLatBound = 0.0;
            m_southLatBound = 0.0;
            m_westLonBound = 0.0;
        }

        public override void Build()
        {
            if (m_eastLonBound <= m_westLonBound
              || m_northLatBound <= m_southLatBound
              || m_destWidth <= 0
              || m_destHeight <= 0
              || m_pSourceModule == null
              || m_pDestNoiseMap == null)
            {
                throw new ArgumentException();
            }

            // Resize the destination noise map so that it can store the new output
            // values from the source model.
            m_pDestNoiseMap.SetSize(m_destWidth, m_destHeight);

            // Create the plane model.
            Sphere sphereModel = new Sphere();
            sphereModel.SetModule(m_pSourceModule);

            double lonExtent = m_eastLonBound - m_westLonBound;
            double latExtent = m_northLatBound - m_southLatBound;
            double xDelta = lonExtent / (double)m_destWidth;
            double yDelta = latExtent / (double)m_destHeight;

            Stopwatch sw = new Stopwatch();
            sw.Start();
            // Fill every point in the noise map with the output values from the model.
            //Parallel.For(0, m_destHeight, y =>
            for (int y = 0; y < m_destHeight; y++)
            {
                for (int x = 0; x < m_destWidth; x++)
                {
                    float curValue = (float)sphereModel.GetValue(m_southLatBound + y * yDelta, m_westLonBound + x * xDelta);
                    m_pDestNoiseMap[x, y] = curValue;
                }
                if (m_pCallback != null)
                {
                    m_pCallback(y);
                }

            //});
            }
            sw.Stop();
            Debug.WriteLine("NoiseMapBuilderSphere: " + sw.Elapsed);
        }

        /// Returns the eastern boundary of the spherical noise map.
        ///
        /// @returns The eastern boundary of the noise map, in degrees.
        public double GetEastLonBound()
        {
            return m_eastLonBound;
        }

        /// Returns the northern boundary of the spherical noise map
        ///
        /// @returns The northern boundary of the noise map, in degrees.
        public double GetNorthLatBound()
        {
            return m_northLatBound;
        }

        /// Returns the southern boundary of the spherical noise map
        ///
        /// @returns The southern boundary of the noise map, in degrees.
        public double GetSouthLatBound()
        {
            return m_southLatBound;
        }

        /// Returns the western boundary of the spherical noise map
        ///
        /// @returns The western boundary of the noise map, in degrees.
        public double GetWestLonBound()
        {
            return m_westLonBound;
        }

        /// Sets the coordinate boundaries of the noise map.
        ///
        /// @param southLatBound The southern boundary of the noise map, in
        /// degrees.
        /// @param northLatBound The northern boundary of the noise map, in
        /// degrees.
        /// @param westLonBound The western boundary of the noise map, in
        /// degrees.
        /// @param eastLonBound The eastern boundary of the noise map, in
        /// degrees.
        ///
        /// @pre The southern boundary is less than the northern boundary.
        /// @pre The western boundary is less than the eastern boundary.
        ///
        /// @throw noise::ExceptionInvalidParam See the preconditions.
        public void SetBounds(double southLatBound, double northLatBound,
          double westLonBound, double eastLonBound)
        {
            if (southLatBound >= northLatBound
              || westLonBound >= eastLonBound)
            {
                throw new ArgumentException();
            }

            m_southLatBound = southLatBound;
            m_northLatBound = northLatBound;
            m_westLonBound = westLonBound;
            m_eastLonBound = eastLonBound;
        }



        /// Eastern boundary of the spherical noise map, in degrees.
        private double m_eastLonBound;

        /// Northern boundary of the spherical noise map, in degrees.
        private double m_northLatBound;

        /// Southern boundary of the spherical noise map, in degrees.
        private double m_southLatBound;

        /// Western boundary of the spherical noise map, in degrees.
        private double m_westLonBound;
    }


    /// Renders an image from a noise map.
    ///
    /// This class renders an image given the contents of a noise-map object.
    ///
    /// An application can configure the output of the image in three ways:
    /// - Specify the color gradient.
    /// - Specify the light source parameters.
    /// - Specify the background image.
    ///
    /// <b>Specify the color gradient</b>
    ///
    /// This class uses a color gradient to calculate the color for each pixel
    /// in the destination image according to the value from the corresponding
    /// position in the noise map.
    ///
    /// A color gradient is a list of gradually-changing colors.  A color
    /// gradient is defined by a list of <i>gradient points</i>.  Each
    /// gradient point has a position and a color.  In a color gradient, the
    /// colors between two adjacent gradient points are linearly interpolated.
    ///
    /// For example, suppose this class contains the following color gradient:
    ///
    /// - -1.0 maps to dark blue.
    /// - -0.2 maps to light blue.
    /// - -0.1 maps to tan.
    /// - 0.0 maps to green.
    /// - 1.0 maps to white.
    ///
    /// The value 0.5 maps to a greenish-white color because 0.5 is halfway
    /// between 0.0 (mapped to green) and 1.0 (mapped to white).
    ///
    /// The value -0.6 maps to a medium blue color because -0.6 is halfway
    /// between -1.0 (mapped to dark blue) and -0.2 (mapped to light blue).
    ///
    /// The color gradient requires a minimum of two gradient points.
    ///
    /// This class contains two pre-made gradients: a grayscale gradient and a
    /// color gradient suitable for terrain.  To use these pre-made gradients,
    /// call the BuildGrayscaleGradient() or BuildTerrainGradient() methods,
    /// respectively.
    ///
    /// @note The color value passed to AddGradientPoint() has an alpha
    /// channel.  This alpha channel specifies how a pixel in the background
    /// image (if specified) is blended with the calculated color.  If the
    /// alpha value is high, this class weighs the blend towards the
    /// calculated color, and if the alpha value is low, this class weighs the
    /// blend towards the color from the corresponding pixel in the background
    /// image.
    ///
    /// <b>Specify the light source parameters</b>
    ///
    /// This class contains a parallel light source that lights the image.  It
    /// interprets the noise map as a bump map.
    ///
    /// To enable or disable lighting, pass a Boolean value to the
    /// EnableLight() method.
    ///
    /// To set the position of the light source in the "sky", call the
    /// SetLightAzimuth() and SetLightElev() methods.
    ///
    /// To set the color of the light source, call the SetLightColor() method.
    ///
    /// To set the intensity of the light source, call the SetLightIntensity()
    /// method.  A good intensity value is 2.0, although that value tends to
    /// "wash out" very light colors from the image.
    /// 
    /// To set the contrast amount between areas in light and areas in shadow,
    /// call the SetLightContrast() method.  Determining the correct contrast
    /// amount requires some trial and error, but if your application
    /// interprets the noise map as a height map that has its elevation values
    /// measured in meters and has a horizontal resolution of @a h meters, a
    /// good contrast amount to use is ( 1.0 / @a h ).
    /// 
    /// <b>Specify the background image</b>
    ///
    /// To specify a background image, pass an Image object to the
    /// SetBackgroundImage() method.
    ///
    /// This class determines the color of a pixel in the destination image by
    /// blending the calculated color with the color of the corresponding
    /// pixel from the background image.
    ///
    /// The blend amount is determined by the alpha of the calculated color.
    /// If the alpha value is high, this class weighs the blend towards the
    /// calculated color, and if the alpha value is low, this class weighs the
    /// blend towards the color from the corresponding pixel in the background
    /// image.
    ///
    /// <b>Rendering the image</b>
    ///
    /// To render the image, perform the following steps:
    /// - Pass a NoiseMap object to the SetSourceNoiseMap() method.
    /// - Pass an Image object to the SetDestImage() method.
    /// - Pass an Image object to the SetBackgroundImage() method (optional)
    /// - Call the Render() method.
    public class RendererImage
    {
        /// Constructor.
        public RendererImage()
        {
            m_isLightEnabled = false;
            m_isWrapEnabled = false;
            m_lightAzimuth = 45.0;
            m_lightBrightness = 1.0;
            m_lightColor = new Color(255, 255, 255, 255);
            m_lightContrast = 1.0;
            m_lightElev = 45.0;
            m_lightIntensity = 1.0;
            m_pBackgroundImage = null;
            m_pDestImage = null;
            m_pSourceNoiseMap = null;
            m_recalcLightValues = true;

            BuildGrayscaleGradient();
        }

        /// Adds a gradient point to this gradient object.
        ///
        /// @param gradientPos The position of this gradient point.
        /// @param gradientColor The color of this gradient point.
        ///
        /// @pre No two gradient points have the same position.
        ///
        /// @throw noise::ExceptionInvalidParam See the preconditions.
        ///
        /// This object uses a color gradient to calculate the color for each
        /// pixel in the destination image according to the value from the
        /// corresponding position in the noise map.
        ///
        /// The gradient requires a minimum of two gradient points.
        ///
        /// The specified color value passed to this method has an alpha
        /// channel.  This alpha channel specifies how a pixel in the
        /// background image (if specified) is blended with the calculated
        /// color.  If the alpha value is high, this object weighs the blend
        /// towards the calculated color, and if the alpha value is low, this
        /// object weighs the blend towards the color from the corresponding
        /// pixel in the background image.
        public void AddGradientPoint(double gradientPos, Color gradientColor)
        {
            m_gradient.AddGradientPoint(gradientPos, gradientColor);
        }

        public GradientColor Gradient
        {
            get { return m_gradient; }
            set { m_gradient = value; }
        }

        /// Builds a grayscale gradient.
        ///
        /// @post The original gradient is cleared and a grayscale gradient is
        /// created.
        ///
        /// This color gradient contains the following gradient points:
        /// - -1.0 maps to black
        /// - 1.0 maps to white
        public void BuildGrayscaleGradient()
        {
            ClearGradient();
            m_gradient.AddGradientPoint(-1.0, new Color(0, 0, 0, 255));
            m_gradient.AddGradientPoint(1.0, new Color(255, 255, 255, 255));
        }

        /// Builds a color gradient suitable for terrain.
        ///
        /// @post The original gradient is cleared and a terrain gradient is
        /// created.
        ///
        /// This gradient color at position 0.0 is the "sea level".  Above
        /// that value, the gradient contains greens, browns, and whites.
        /// Below that value, the gradient contains various shades of blue.
        public void BuildTerrainGradient()
        {
            ClearGradient();
            m_gradient.AddGradientPoint(-1.00, new Color(0, 0, 128, 255));
            m_gradient.AddGradientPoint(-0.20, new Color(32, 64, 128, 255));
            m_gradient.AddGradientPoint(-0.04, new Color(64, 96, 192, 255));
            m_gradient.AddGradientPoint(-0.02, new Color(192, 192, 128, 255));
            m_gradient.AddGradientPoint(0.00, new Color(0, 192, 0, 255));
            m_gradient.AddGradientPoint(0.25, new Color(192, 192, 0, 255));
            m_gradient.AddGradientPoint(0.50, new Color(160, 96, 64, 255));
            m_gradient.AddGradientPoint(0.75, new Color(128, 255, 255, 255));
            m_gradient.AddGradientPoint(1.00, new Color(255, 255, 255, 255));
        }

        /// Clears the color gradient.
        ///
        /// Before calling the Render() method, the application must specify a
        /// new color gradient with at least two gradient points.
        public void ClearGradient()
        {
            m_gradient.Clear();
        }

        /// Enables or disables the light source.
        ///
        /// @param enable A flag that enables or disables the light source.
        ///
        /// If the light source is enabled, this object will interpret the
        /// noise map as a bump map.
        public void EnableLight(bool enable = true)
        {
            m_isLightEnabled = enable;
        }

        /// Enables or disables noise-map wrapping.
        ///
        /// @param enable A flag that enables or disables noise-map wrapping.
        ///
        /// This object requires five points (the initial point and its four
        /// neighbors) to calculate light shading.  If wrapping is enabled,
        /// and the initial point is on the edge of the noise map, the
        /// appropriate neighbors that lie outside of the noise map will
        /// "wrap" to the opposite side(s) of the noise map.  Otherwise, the
        /// appropriate neighbors are cropped to the edge of the noise map.
        ///
        /// Enabling wrapping is useful when creating spherical renderings and
        /// tileable textures.
        public void EnableWrap(bool enable = true)
        {
            m_isWrapEnabled = enable;
        }

        /// Returns the azimuth of the light source, in degrees.
        ///
        /// @returns The azimuth of the light source.
        ///
        /// The azimuth is the location of the light source around the
        /// horizon:
        /// - 0.0 degrees is east.
        /// - 90.0 degrees is north.
        /// - 180.0 degrees is west.
        /// - 270.0 degrees is south.
        public double GetLightAzimuth()
        {
            return m_lightAzimuth;
        }

        /// Returns the brightness of the light source.
        ///
        /// @returns The brightness of the light source.
        public double GetLightBrightness()
        {
            return m_lightBrightness;
        }

        /// Returns the color of the light source.
        ///
        /// @returns The color of the light source.
        public Color GetLightColor()
        {
            return m_lightColor;
        }

        /// Returns the contrast of the light source.
        ///
        /// @returns The contrast of the light source.
        ///
        /// The contrast specifies how sharp the boundary is between the
        /// light-facing areas and the shadowed areas.
        ///
        /// The contrast determines the difference between areas in light and
        /// areas in shadow.  Determining the correct contrast amount requires
        /// some trial and error, but if your application interprets the noise
        /// map as a height map that has a spatial resolution of @a h meters
        /// and an elevation resolution of 1 meter, a good contrast amount to
        /// use is ( 1.0 / @a h ).
        public double GetLightContrast()
        {
            return m_lightContrast;
        }

        /// Returns the elevation of the light source, in degrees.
        ///
        /// @returns The elevation of the light source.
        ///
        /// The elevation is the angle above the horizon:
        /// - 0 degrees is on the horizon.
        /// - 90 degrees is straight up.
        public double GetLightElev()
        {
            return m_lightElev;
        }

        /// Returns the intensity of the light source.
        ///
        /// @returns The intensity of the light source.
        public double GetLightIntensity()
        {
            return m_lightIntensity;
        }

        /// Determines if the light source is enabled.
        ///
        /// @returns
        /// - @a true if the light source is enabled.
        /// - @a false if the light source is disabled.
        public bool IsLightEnabled()
        {
            return m_isLightEnabled;
        }

        /// Determines if noise-map wrapping is enabled.
        ///
        /// @returns
        /// - @a true if noise-map wrapping is enabled.
        /// - @a false if noise-map wrapping is disabled.
        ///
        /// This object requires five points (the initial point and its four
        /// neighbors) to calculate light shading.  If wrapping is enabled,
        /// and the initial point is on the edge of the noise map, the
        /// appropriate neighbors that lie outside of the noise map will
        /// "wrap" to the opposite side(s) of the noise map.  Otherwise, the
        /// appropriate neighbors are cropped to the edge of the noise map.
        ///
        /// Enabling wrapping is useful when creating spherical renderings and
        /// tileable textures
        public bool IsWrapEnabled()
        {
            return m_isWrapEnabled;
        }

        /// Renders the destination image using the contents of the source
        /// noise map and an optional background image.
        ///
        /// @pre SetSourceNoiseMap() has been previously called.
        /// @pre SetDestImage() has been previously called.
        /// @pre There are at least two gradient points in the color gradient.
        /// @pre No two gradient points have the same position.
        /// @pre If a background image was specified, it has the exact same
        /// size as the source height map.
        ///
        /// @post The original contents of the destination image is destroyed.
        ///
        /// @throw noise::ExceptionInvalidParam See the preconditions.
        ///
        /// The background image and the destination image can safely refer to
        /// the same image, although in this case, the destination image is
        /// irretrievably blended into the background image.
        public void Render()
        {
            if (m_pSourceNoiseMap == null
              || m_pDestImage == null
              || m_pSourceNoiseMap.Width <= 0
              || m_pSourceNoiseMap.Height <= 0
              || m_gradient.GetGradientPointCount() < 2)
            {
                throw new ArgumentException();
            }

            int width = m_pSourceNoiseMap.Width;
            int height = m_pSourceNoiseMap.Height;

            // If a background image was provided, make sure it is the same size the
            // source noise map.
            if (m_pBackgroundImage != null)
            {
                if (m_pBackgroundImage.Width != width
                  || m_pBackgroundImage.Height != height)
                {
                    throw new ArgumentException();
                }
            }

            // Create the destination image.  It is safe to reuse it if this is also the
            // background image.
            if (m_pDestImage != m_pBackgroundImage)
            {
                m_pDestImage.SetSize(width, height);
            }

            Stopwatch sw = new Stopwatch();
            sw.Start();
            for (int y = 0; y < height; y++)
            //Parallel.For(0, height, y =>
            {
                for (int x = 0; x < width; x++)
                {

                    // Get the color based on the value at the current point in the noise
                    // map.
                    Color destColor = m_gradient.GetColor(m_pSourceNoiseMap[x, y]);

                    // If lighting is enabled, calculate the light intensity based on the
                    // rate of change at the current point in the noise map.
                    double lightIntensity;
                    if (m_isLightEnabled)
                    {

                        // Calculate the positions of the current point's four-neighbors.
                        int xLeftOffset, xRightOffset;
                        int yUpOffset, yDownOffset;
                        if (m_isWrapEnabled)
                        {
                            if (x == 0)
                            {
                                xLeftOffset = width - 1;
                                xRightOffset = x + 1;
                            }
                            else if (x == width - 1)
                            {
                                xLeftOffset = x - 1;
                                xRightOffset = 0;
                            }
                            else
                            {
                                xLeftOffset = x - 1;
                                xRightOffset = x + 1;
                            }
                            if (y == 0)
                            {
                                yDownOffset = height - 1;
                                yUpOffset = 1;
                            }
                            else if (y == height - 1)
                            {
                                yDownOffset = y - 1;
                                yUpOffset = 0;
                            }
                            else
                            {
                                yDownOffset = y - 1;
                                yUpOffset = y + 1;
                            }
                        }
                        else
                        {
                            if (x == 0)
                            {
                                xLeftOffset = 0;
                                xRightOffset = 1;
                            }
                            else if (x == width - 1)
                            {
                                xLeftOffset = x - 1;
                                xRightOffset = 0;
                            }
                            else
                            {
                                xLeftOffset = x - 1;
                                xRightOffset = x + 1;
                            }
                            if (y == 0)
                            {
                                yDownOffset = 0;
                                yUpOffset = 1;
                            }
                            else if (y == height - 1)
                            {
                                yDownOffset = y - 1;
                                yUpOffset = 0;
                            }
                            else
                            {
                                yDownOffset = y - 1;
                                yUpOffset = y + 1;
                            }
                        }

                        // Get the noise value of the current point in the source noise map
                        // and the noise values of its four-neighbors.
                        double nc = (double)m_pSourceNoiseMap[x, y];
                        double nl = (double)m_pSourceNoiseMap[xLeftOffset, y];
                        double nr = (double)m_pSourceNoiseMap[xRightOffset, y];
                        double nd = (double)m_pSourceNoiseMap[x, yDownOffset];
                        double nu = (double)m_pSourceNoiseMap[x, yUpOffset];

                        // Now we can calculate the lighting intensity.
                        lightIntensity = CalcLightIntensity(nc, nl, nr, nd, nu);
                        lightIntensity *= m_lightBrightness;
                    }
                    else
                    {
                        // These values will apply no lighting to the destination image.
                        lightIntensity = 1.0;
                    }

                    // Get the current background color from the background image.
                    Color backgroundColor = new Color(255, 255, 255, 255);
                    if (m_pBackgroundImage != null)
                    {
                        backgroundColor = m_pBackgroundImage[x, y];
                    }

                    // Blend the destination color, background color, and the light
                    // intensity together, then update the destination image with that
                    // color.                   
                    Color color = CalcDestColor(destColor, backgroundColor, lightIntensity);

                    m_pDestImage[x, y] = color;
                }
             }
            //});
            sw.Stop();
            Debug.WriteLine("RendererImage: " + sw.Elapsed);

        }


        /// Sets the background image.
        ///
        /// @param backgroundImage The background image.
        ///
        /// If a background image has been specified, the Render() method
        /// blends the pixels from the background image onto the corresponding
        /// pixels in the destination image.  The blending weights are
        /// determined by the alpha channel in the pixels in the destination
        /// image.
        ///
        /// The destination image must exist throughout the lifetime of this
        /// object unless another image replaces that image.
        public void SetBackgroundImage(NoiseImage backgroundImage)
        {
            m_pBackgroundImage = backgroundImage;
        }

        /// Sets the destination image.
        ///
        /// @param destImage The destination image.
        ///
        /// The destination image will contain the rendered image after a
        /// successful call to the Render() method.
        ///
        /// The destination image must exist throughout the lifetime of this
        /// object unless another image replaces that image.
        public void SetDestImage(NoiseImage destImage)
        {
            m_pDestImage = destImage;
        }

        /// Sets the azimuth of the light source, in degrees.
        ///
        /// @param lightAzimuth The azimuth of the light source.
        ///
        /// The azimuth is the location of the light source around the
        /// horizon:
        /// - 0.0 degrees is east.
        /// - 90.0 degrees is north.
        /// - 180.0 degrees is west.
        /// - 270.0 degrees is south.
        ///
        /// Make sure the light source is enabled via a call to the
        /// EnableLight() method before calling the Render() method.
        public void SetLightAzimuth(double lightAzimuth)
        {
            m_lightAzimuth = lightAzimuth;
            m_recalcLightValues = true;
        }

        /// Sets the brightness of the light source.
        ///
        /// @param lightBrightness The brightness of the light source.
        ///
        /// Make sure the light source is enabled via a call to the
        /// EnableLight() method before calling the Render() method.
        public void SetLightBrightness(double lightBrightness)
        {
            m_lightBrightness = lightBrightness;
            m_recalcLightValues = true;
        }

        /// Sets the color of the light source.
        ///
        /// @param lightColor The light color.
        ///
        /// Make sure the light source is enabled via a call to the
        /// EnableLight() method before calling the Render() method.
        public void SetLightColor(Color lightColor)
        {
            m_lightColor = lightColor;
        }

        /// Sets the contrast of the light source.
        ///
        /// @param lightContrast The contrast of the light source.
        ///
        /// @pre The specified light contrast is positive.
        ///
        /// @throw noise::ExceptionInvalidParam See the preconditions.
        ///
        /// The contrast specifies how sharp the boundary is between the
        /// light-facing areas and the shadowed areas.
        ///
        /// The contrast determines the difference between areas in light and
        /// areas in shadow.  Determining the correct contrast amount requires
        /// some trial and error, but if your application interprets the noise
        /// map as a height map that has a spatial resolution of @a h meters
        /// and an elevation resolution of 1 meter, a good contrast amount to
        /// use is ( 1.0 / @a h ).
        ///
        /// Make sure the light source is enabled via a call to the
        /// EnableLight() method before calling the Render() method.
        public void SetLightContrast(double lightContrast)
        {
            if (lightContrast <= 0.0)
            {
                throw new ArgumentException();
            }

            m_lightContrast = lightContrast;
            m_recalcLightValues = true;
        }

        /// Sets the elevation of the light source, in degrees.
        ///
        /// @param lightElev The elevation of the light source.
        ///
        /// The elevation is the angle above the horizon:
        /// - 0 degrees is on the horizon.
        /// - 90 degrees is straight up.
        ///
        /// Make sure the light source is enabled via a call to the
        /// EnableLight() method before calling the Render() method.
        public void SetLightElev(double lightElev)
        {
            m_lightElev = lightElev;
            m_recalcLightValues = true;
        }

        /// Returns the intensity of the light source.
        ///
        /// @returns The intensity of the light source.
        ///
        /// A good value for intensity is 2.0.
        ///
        /// Make sure the light source is enabled via a call to the
        /// EnableLight() method before calling the Render() method.
        public void SetLightIntensity(double lightIntensity)
        {
            if (lightIntensity < 0.0)
            {
                throw new ArgumentException();
            }

            m_lightIntensity = lightIntensity;
            m_recalcLightValues = true;
        }

        /// Sets the source noise map.
        ///
        /// @param sourceNoiseMap The source noise map.
        ///
        /// The destination image must exist throughout the lifetime of this
        /// object unless another image replaces that image.
        public void SetSourceNoiseMap(NoiseMap sourceNoiseMap)
        {
            m_pSourceNoiseMap = sourceNoiseMap;
        }

        /// Calculates the destination color.
        ///
        /// @param sourceColor The source color generated from the color
        /// gradient.
        /// @param backgroundColor The color from the background image at the
        /// corresponding position.
        /// @param lightValue The intensity of the light at that position.
        ///
        /// @returns The destination color.
        private Color CalcDestColor(Color sourceColor, Color backgroundColor, double lightValue)
        {
            double sourceRed = (double)sourceColor.red / 255.0;
            double sourceGreen = (double)sourceColor.green / 255.0;
            double sourceBlue = (double)sourceColor.blue / 255.0;
            double sourceAlpha = (double)sourceColor.alpha / 255.0;
            double backgroundRed = (double)backgroundColor.red / 255.0;
            double backgroundGreen = (double)backgroundColor.green / 255.0;
            double backgroundBlue = (double)backgroundColor.blue / 255.0;

            // First, blend the source color to the background color using the alpha
            // of the source color.
            double red = Utils.InterpolateLinear(backgroundRed, sourceRed, sourceAlpha);
            double green = Utils.InterpolateLinear(backgroundGreen, sourceGreen, sourceAlpha);
            double blue = Utils.InterpolateLinear(backgroundBlue, sourceBlue, sourceAlpha);

            if (m_isLightEnabled)
            {
                // Now calculate the light color.
                double lightRed = lightValue * (double)m_lightColor.red / 255.0;
                double lightGreen = lightValue * (double)m_lightColor.green / 255.0;
                double lightBlue = lightValue * (double)m_lightColor.blue / 255.0;

                // Apply the light color to the new color.
                red *= lightRed;
                green *= lightGreen;
                blue *= lightBlue;
            }

            // Clamp the color channels to the (0..1) range.
            red = (red < 0.0) ? 0.0 : red;
            red = (red > 1.0) ? 1.0 : red;
            green = (green < 0.0) ? 0.0 : green;
            green = (green > 1.0) ? 1.0 : green;
            blue = (blue < 0.0) ? 0.0 : blue;
            blue = (blue > 1.0) ? 1.0 : blue;

            // Rescale the color channels to the noise::uint8 (0..255) range and return
            // the new color.
            Color newColor = new Color((byte)((uint)(red * 255.0) & 0xff),
                                      (byte)((uint)(green * 255.0) & 0xff),
                                      (byte)((uint)(blue * 255.0) & 0xff),
                                      Math.Max(sourceColor.alpha, backgroundColor.alpha));
            return newColor;
        }


        /// Calculates the intensity of the light given some elevation values.
        ///
        /// @param center Elevation of the center point.
        /// @param left Elevation of the point directly left of the center
        /// point.
        /// @param right Elevation of the point directly right of the center
        /// point.
        /// @param down Elevation of the point directly below the center
        /// point.
        /// @param up Elevation of the point directly above the center point.
        ///
        /// These values come directly from the noise map.
        private double CalcLightIntensity(double center, double left, double right, double down, double up)
        {
            // Recalculate the sine and cosine of the various light values if
            // necessary so it does not have to be calculated each time this method is
            // called.
            if (m_recalcLightValues)
            {
                m_cosAzimuth = Math.Cos(m_lightAzimuth * Utils.DegToRad);
                m_sinAzimuth = Math.Sin(m_lightAzimuth * Utils.DegToRad);
                m_cosElev = Math.Cos(m_lightElev * Utils.DegToRad);
                m_sinElev = Math.Sin(m_lightElev * Utils.DegToRad);
                m_recalcLightValues = false;
            }

            // Now do the lighting calculations.
            const double I_MAX = 1.0;
            double io = I_MAX * Utils.Sqrt2 * m_sinElev / 2.0;
            double ix = (I_MAX - io) * m_lightContrast * Utils.Sqrt2 * m_cosElev
              * m_cosAzimuth;
            double iy = (I_MAX - io) * m_lightContrast * Utils.Sqrt2 * m_cosElev
              * m_sinAzimuth;
            double intensity = (ix * (left - right) + iy * (down - up) + io);
            if (intensity < 0.0)
            {
                intensity = 0.0;
            }
            return intensity;
        }

        /// The cosine of the azimuth of the light source.
        private double m_cosAzimuth;

        /// The cosine of the elevation of the light source.
        private double m_cosElev;

        /// The color gradient used to specify the image colors.
        private GradientColor m_gradient = new GradientColor();

        /// A flag specifying whether lighting is enabled.
        private bool m_isLightEnabled;

        /// A flag specifying whether wrapping is enabled.
        private bool m_isWrapEnabled;

        /// The azimuth of the light source, in degrees.
        private double m_lightAzimuth;

        /// The brightness of the light source.
        private double m_lightBrightness;

        /// The color of the light source.
        private Color m_lightColor;

        /// The contrast between areas in light and areas in shadow.
        private double m_lightContrast;

        /// The elevation of the light source, in degrees.
        private double m_lightElev;

        /// The intensity of the light source.
        private double m_lightIntensity;

        /// A pointer to the background image.
        private NoiseImage m_pBackgroundImage;

        /// A pointer to the destination image.
        private NoiseImage m_pDestImage;

        /// A pointer to the source noise map.
        private NoiseMap m_pSourceNoiseMap;

        /// Used by the CalcLightIntensity() method to recalculate the light
        /// values only if the light parameters change.
        ///
        /// When the light parameters change, this value is set to True.  When
        /// the CalcLightIntensity() method is called, this value is set to
        /// false.
        private bool m_recalcLightValues;

        /// The sine of the azimuth of the light source.
        private double m_sinAzimuth;

        /// The sine of the elevation of the light source.
        private double m_sinElev;

    }


    /// Renders a normal map from a noise map.
    ///
    /// This class renders an image containing the normal vectors from a noise
    /// map object.  This image can then be used as a bump map for a 3D
    /// application or game.
    ///
    /// This class encodes the (x, y, z) components of the normal vector into
    /// the (red, green, blue) channels of the image.  Like any 24-bit
    /// true-color image, the channel values range from 0 to 255.  0
    /// represents a normal coordinate of -1.0 and 255 represents a normal
    /// coordinate of +1.0.
    ///
    /// You should also specify the <i>bump height</i> before rendering the
    /// normal map.  The bump height specifies the ratio of spatial resolution
    /// to elevation resolution.  For example, if your noise map has a spatial
    /// resolution of 30 meters and an elevation resolution of one meter, set
    /// the bump height to 1.0 / 30.0.
    ///
    /// <b>Rendering the normal map</b>
    ///
    /// To render the image containing the normal map, perform the following
    /// steps:
    /// - Pass a NoiseMap object to the SetSourceNoiseMap() method.
    /// - Pass an Image object to the SetDestImage() method.
    /// - Call the Render() method.
    public class RendererNormalMap
    {
        /// Constructor.
        public RendererNormalMap()
        {
            m_bumpHeight = 1.0;
            m_isWrapEnabled = false;
            m_pDestImage = null;
            m_pSourceNoiseMap = null;
        }

        /// Enables or disables noise-map wrapping.
        ///
        /// @param enable A flag that enables or disables noise-map wrapping.
        ///
        /// This object requires three points (the initial point and the right
        /// and up neighbors) to calculate the normal vector at that point.
        /// If wrapping is/ enabled, and the initial point is on the edge of
        /// the noise map, the appropriate neighbors that lie outside of the
        /// noise map will "wrap" to the opposite side(s) of the noise map.
        /// Otherwise, the appropriate neighbors are cropped to the edge of
        /// the noise map.
        ///
        /// Enabling wrapping is useful when creating spherical and tileable
        /// normal maps.
        public void EnableWrap(bool enable = true)
        {
            m_isWrapEnabled = enable;
        }

        /// Returns the bump height.
        ///
        /// @returns The bump height.
        ///
        /// The bump height specifies the ratio of spatial resolution to
        /// elevation resolution.  For example, if your noise map has a
        /// spatial resolution of 30 meters and an elevation resolution of one
        /// meter, set the bump height to 1.0 / 30.0.
        ///
        /// The spatial resolution and elevation resolution are determined by
        /// the application.
        public double GetBumpHeight()
        {
            return m_bumpHeight;
        }

        /// Determines if noise-map wrapping is enabled.
        ///
        /// @returns
        /// - @a true if noise-map wrapping is enabled.
        /// - @a false if noise-map wrapping is disabled.
        ///
        /// This object requires three points (the initial point and the right
        /// and up neighbors) to calculate the normal vector at that point.
        /// If wrapping is/ enabled, and the initial point is on the edge of
        /// the noise map, the appropriate neighbors that lie outside of the
        /// noise map will "wrap" to the opposite side(s) of the noise map.
        /// Otherwise, the appropriate neighbors are cropped to the edge of
        /// the noise map.
        ///
        /// Enabling wrapping is useful when creating spherical and tileable
        /// normal maps.
        public bool IsWrapEnabled()
        {
            return m_isWrapEnabled;
        }

        /// Renders the noise map to the destination image.
        ///
        /// @pre SetSourceNoiseMap() has been previously called.
        /// @pre SetDestImage() has been previously called.
        ///
        /// @post The original contents of the destination image is destroyed.
        ///
        /// @throw noise::ExceptionInvalidParam See the preconditions.
        public void Render()
        {
            if (m_pSourceNoiseMap == null
              || m_pDestImage == null
              || m_pSourceNoiseMap.Width <= 0
              || m_pSourceNoiseMap.Height <= 0)
            {
                throw new ArgumentException();
            }

            int width = m_pSourceNoiseMap.Width;
            int height = m_pSourceNoiseMap.Height;

            for (int y = 0; y < height; y++)
            {
                for (int x = 0; x < width; x++)
                {

                    // Calculate the positions of the current point's right and up
                    // neighbors.
                    int xRightOffset, yUpOffset;
                    if (m_isWrapEnabled)
                    {
                        if (x == width - 1)
                        {
                            xRightOffset = 0;
                        }
                        else
                        {
                            xRightOffset = x + 1;
                        }
                        if (y == height - 1)
                        {
                            yUpOffset = 0;
                        }
                        else
                        {
                            yUpOffset = y + 1;
                        }
                    }
                    else
                    {
                        if (x == (int)width - 1)
                        {
                            xRightOffset = x;
                        }
                        else
                        {
                            xRightOffset = x + 1;
                        }
                        if (y == (int)height - 1)
                        {
                            yUpOffset = y;
                        }
                        else
                        {
                            yUpOffset = y + 1;
                        }
                    }

                    // Get the noise value of the current point in the source noise map
                    // and the noise values of its right and up neighbors.
                    double nc = (double)(m_pSourceNoiseMap[x, y]);
                    double nr = (double)(m_pSourceNoiseMap[xRightOffset, y]);
                    double nu = (double)(m_pSourceNoiseMap[x, yUpOffset]);

                    // Calculate the normal product.
                    m_pDestImage[x, y] = CalcNormalColor(nc, nr, nu, m_bumpHeight);
                }
            }
        }

        /// Sets the bump height.
        ///
        /// @param bumpHeight The bump height.
        ///
        /// The bump height specifies the ratio of spatial resolution to
        /// elevation resolution.  For example, if your noise map has a
        /// spatial resolution of 30 meters and an elevation resolution of one
        /// meter, set the bump height to 1.0 / 30.0.
        ///
        /// The spatial resolution and elevation resolution are determined by
        /// the application.
        public void SetBumpHeight(double bumpHeight)
        {
            m_bumpHeight = bumpHeight;
        }

        /// Sets the destination image.
        ///
        /// @param destImage The destination image.
        ///
        /// The destination image will contain the normal map after a
        /// successful call to the Render() method.
        ///
        /// The destination image must exist throughout the lifetime of this
        /// object unless another image replaces that image.
        public void SetDestImage(NoiseImage destImage)
        {
            m_pDestImage = destImage;
        }

        /// Sets the source noise map.
        ///
        /// @param sourceNoiseMap The source noise map.
        ///
        /// The destination image must exist throughout the lifetime of this
        /// object unless another image replaces that image.
        public void SetSourceNoiseMap(NoiseMap sourceNoiseMap)
        {
            m_pSourceNoiseMap = sourceNoiseMap;
        }



        /// Calculates the normal vector at a given point on the noise map.
        ///
        /// @param nc The height of the given point in the noise map.
        /// @param nr The height of the left neighbor.
        /// @param nu The height of the up neighbor.
        /// @param bumpHeight The bump height.
        ///
        /// @returns The normal vector represented as a color.
        ///
        /// This method encodes the (x, y, z) components of the normal vector
        /// into the (red, green, blue) channels of the returned color.  In
        /// order to represent the vector as a color, each coordinate of the
        /// normal is mapped from the -1.0 to 1.0 range to the 0 to 255 range.
        ///
        /// The bump height specifies the ratio of spatial resolution to
        /// elevation resolution.  For example, if your noise map has a
        /// spatial resolution of 30 meters and an elevation resolution of one
        /// meter, set the bump height to 1.0 / 30.0.
        /// 
        /// The spatial resolution and elevation resolution are determined by
        /// the application.
        private Color CalcNormalColor(double nc, double nr, double nu, double bumpHeight)
        {
            // Calculate the surface normal.
            nc *= bumpHeight;
            nr *= bumpHeight;
            nu *= bumpHeight;
            double ncr = (nc - nr);
            double ncu = (nc - nu);
            double d = Math.Sqrt((ncu * ncu) + (ncr * ncr) + 1);
            double vxc = (nc - nr) / d;
            double vyc = (nc - nu) / d;
            double vzc = 1.0 / d;

            // Map the normal range from the (-1.0 .. +1.0) range to the (0 .. 255)
            // range.
            byte xc, yc, zc;
            xc = (byte)((uint)(Math.Floor((vxc + 1.0) * 127.5)) & 0xff);
            yc = (byte)((uint)(Math.Floor((vyc + 1.0) * 127.5)) & 0xff);
            zc = (byte)((uint)(Math.Floor((vzc + 1.0) * 127.5)) & 0xff);

            return new Color(xc, yc, zc, 0);
        }

        /// The bump height for the normal map.
        private double m_bumpHeight;

        /// A flag specifying whether wrapping is enabled.
        private bool m_isWrapEnabled;

        /// A pointer to the destination image.
        private NoiseImage m_pDestImage;

        /// A pointer to the source noise map.
        private NoiseMap m_pSourceNoiseMap;

    }
}
