using LibNoise;
using LibNoise.Generator;
using LibNoise.Operator;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;

namespace ComplexPlanet
{
    /// <summary>
    /// This program demonstrates how to use the libnoise library to generate
    /// terrain elevations for a complex planetary surface that has the size of the
    /// earth.
    ///
    /// This program outputs a grid of elevation points in geographic (lat/lon)
    /// projection.  This program creates six files from this grid:
    /// - A Terragen terrain (*.ter) file that has its elevation points measured in
    ///   meters.  This file is generated only if the grid of elevation points has
    ///   a spatial resolution  less than 240 meters.
    /// - A raw terrain (*.raw) file that has its elevation points measured in
    ///   meters.  This terrain file contains 16-bit signed big-endian values, in
    ///   row-major order, ordered south to north.
    /// - A Windows bitmap file (*.bmp) that is colored according to elevation and
    ///   lit by an artificial light source.
    /// - A Windows bitmap file (*.bmp) that is colored according to elevation
    ///   only.
    /// - A Windows bitmap file (*.bmp) containing the normals of the terrain.  The
    ///   red channel represents the x normal coordinate, the green channel
    ///   represents the y normal coordinate, and the blue channel represents the z
    ///   normal coordinate.  Initially, the normal coordinates are between -0.5
    ///   and +0.5, but when stored in the bitmap, this range is mapped from 0 to
    ///   255.
    /// - A Windows bitmap file (*.bmp) containing the specularity map of the
    ///   terrain.  Black indicates no specularity, while white indicates full
    ///   specularity.
    ///
    /// The grid of elevation points can have a maximum horizontal resolution of
    /// 0.25 arcseconds (~7.5 meters.)  A higher-resolution grid will cause the
    /// terrain to appear blurry.
    ///
    /// The terrain elevations are generated by a collection of over a hundred
    /// noise modules in a hierarchy of groups and subgroups.  Each group and
    /// subgroup outputs a single output value that originates from a caching
    /// module (noise::Cache).  Each group and subgroup can be thought of
    /// as a single complex noise module that can be used as a source module for
    /// other noise modules.  The caching module was chosen as the source of the
    /// output value to prevent costly recalculations by each group and subgroup
    /// requesting an output value from it.
    ///
    /// The following is a list of module groups and subgroups that build the
    /// planet's terrain:
    ///
    /// Group (continent definition)
    ///   Subgroup (base continent definition)
    ///   Subgroup (continent definition)
    /// Group (terrain type definition)
    ///   Subgroup (terrain type definition)
    /// Group (mountainous terrain)
    ///   Subgroup (mountain base definition)
    ///   Subgroup (high mountainous terrain)
    ///   Subgroup (low mountainous terrain)
    ///   Subgroup (mountainous terrain)
    /// Group (hilly terrain)
    ///   Subgroup (hilly terrain)
    /// Group (plains terrain)
    ///   Subgroup (plains terrain)
    /// Group (badlands terrain)
    ///   Subgroup (badlands sand)
    ///   Subgroup (badlands cliffs)
    ///   Subgroup (badlands terrain)
    /// Group (river positions)
    ///   Subgroup (river positions)
    /// Group (scaled mountainous terrain)
    ///   Subgroup (scaled mountainous terrain)
    /// Group (scaled hilly terrain)
    ///   Subgroup (scaled hilly terrain)
    /// Group (scaled plains terrain)
    ///   Subgroup (scaled plains terrain)
    /// Group (scaled badlands terrain)
    ///   Subgroup (scaled badlands terrain)
    /// Group (final planet)
    ///   Subgroup (continental shelf)
    ///   Subgroup (base continent elevation)
    ///   Subgroup (continents with plains)
    ///   Subgroup (continents with hills)
    ///   Subgroup (continents with mountains)
    ///   Subgroup (continents with badlands)
    ///   Subgroup (continents with rivers)
    ///   Subgroup (unscaled final planet)
    ///   Subgroup (final planet)
    ///
    /// A description of each group and subgroup can be found above the source code
    /// for that group and subgroup.
    ///
    /// Copyright (C) 2004, 2005 by Jason Bevins
    ///
    /// This program is free software; you can redistribute it and/or modify it
    /// under the terms of the GNU General Public License as published by the Free
    /// Software Foundation; either version 2 of the License, or (at your option)
    /// any later version.
    ///
    /// This program is distributed in the hope that it will be useful, but WITHOUT
    /// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
    /// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    /// (COPYING.txt) for more details.
    ///
    /// You should have received a copy of the GNU General Public License along
    /// with this program; if not, write to the Free Software Foundation, Inc., 59
    /// Temple Place, Suite 330, Boston, MA  02111-1307  USA
    ///
    /// The developer's email is jlbezigvins@gmzigail.com (for great email, take
    /// off every 'zig'.)
    ///
    /// </summary>
    class Program
    {
        private static string worldName = "Earth";
        private static String dirname;

        static void Main(string[] args)
        {
            if (args.Length == 1)
                worldName = args[0];

            dirname = worldName + Path.DirectorySeparatorChar;
            if (!Directory.Exists(dirname))
                Directory.CreateDirectory(dirname);
            Stopwatch sw = new Stopwatch();
            sw.Start();
            float[,] hm = ReadElevation();
            if (hm == null)
            {
                hm = ComputePlanet();
            }
            ComputeBiome(hm);
            sw.Stop();  Debug.WriteLine("Total Time: " + sw.Elapsed);           
            Console.WriteLine("Done. Press enter to finish.");
            Console.ReadLine();
        }

        static void ComputeBiome(float[,] hm)
        {
                ClimateSimulator climateSim = new ClimateSimulator(hm);
                climateSim.ComputeClimate();
                NoiseMap climate = new NoiseMap();

                RendererImage renderer = new RendererImage();
                NoiseImage image = new NoiseImage();
                WriterBMP writer = new WriterBMP();
                renderer.SetSourceNoiseMap(climate);
                renderer.SetDestImage(image);

                climate.Map = climateSim.HeatMap;
                renderer.Gradient = Palette.TEMP_19LEV;
                renderer.Render();
                writer.SetSourceImage(image);
                writer.SetDestFilename(dirname + "HeatMap.bmp");
                writer.WriteDestFile();

                //climate.Map = climateSim.PressureMap;
                //renderer.Gradient = Palette.PERC2_9LEV;
                //renderer.Render();
                //writer.SetSourceImage(image);
                //writer.SetDestFilename("PressureMap.bmp");
                //writer.WriteDestFile();

                climate.Map = climateSim.DebugMap;
                renderer.ClearGradient();
                renderer.AddGradientPoint(-1, new Color(0, 0, 255, 255));
                renderer.AddGradientPoint(0, new Color(0, 0, 0, 255));
                renderer.AddGradientPoint(12, new Color(255, 0, 0, 255));
                renderer.AddGradientPoint(25, new Color(128, 128, 0, 255));
                renderer.AddGradientPoint(50, new Color(128, 200, 128, 255));
                renderer.AddGradientPoint(100, new Color(68, 200, 128, 255));
                renderer.AddGradientPoint(200, new Color(68, 200, 68, 255));
                renderer.AddGradientPoint(400, new Color(20, 255, 20, 255));
                renderer.AddGradientPoint(800, new Color(0, 200, 20, 255));
                renderer.AddGradientPoint(900, new Color(0, 255, 0, 255));
                renderer.Render();
                writer.SetSourceImage(image);
                writer.SetDestFilename(dirname + "DebugMap.bmp");
                writer.WriteDestFile();

                //climate.Map = climateSim.WindMap;
                //renderer.ClearGradient(); ;
                //renderer.AddGradientPoint(0, new Color(0, 0, 0, 255));
                //renderer.AddGradientPoint(16, new Color(255, 255, 0, 255));
                //renderer.Render();
                //writer.SetSourceImage(image);
                //writer.SetDestFilename("WindMap.bmp");
                //writer.WriteDestFile();

                climate.Map = climateSim.RainfallMap;
                renderer.ClearGradient();
                renderer.AddGradientPoint(0, new Color(0, 0, 0, 255));
                renderer.AddGradientPoint(210, new Color(0, 255, 0, 255));
                renderer.Render();
                writer.SetSourceImage(image);
                writer.SetDestFilename(dirname + "RainfallMap.bmp");
                writer.WriteDestFile();

                climate.Map = climateSim.BiomeMap;
                renderer.ClearGradient();
                renderer.AddGradientPoint((int)Clim.C_OCEAN, new Color(0, 0, 255)); // OCEAN
                renderer.AddGradientPoint((int)Clim.C_BARELAND, new Color(90, 184, 105));   // BARELAND
                renderer.AddGradientPoint((int)Clim.C_MOUNTAIN, new Color(190, 172, 131));   // MOUNTAIN
                renderer.AddGradientPoint((int)Clim.C_OCEANICE, new Color(225, 225, 225));   // OCEANICE
                renderer.AddGradientPoint((int)Clim.C_TUNDRA, new Color(175, 219, 162));   // TUNDRA
                renderer.AddGradientPoint((int)Clim.C_STEPPE, new Color(90, 184, 70));   // STEPPE
                renderer.AddGradientPoint((int)Clim.C_DESERT, new Color(255, 255, 96));   // DESERT
                renderer.AddGradientPoint((int)Clim.C_SAVANA, new Color(96, 255, 96));   // SAVANA
                renderer.AddGradientPoint((int)Clim.C_DECIDUOUS, new Color(47, 115, 49));   // DECIDUOUS 
                renderer.AddGradientPoint((int)Clim.C_JUNGLE, new Color(0, 173, 0));   // JUNGLE  
                renderer.AddGradientPoint((int)Clim.C_SWAMP, new Color(131, 184, 105));  // SWAMP
                renderer.AddGradientPoint((int)Clim.C_LANDICE, new Color(225, 225, 225));  // LANDICE
                renderer.Render();
                writer.SetSourceImage(image);
                writer.SetDestFilename(dirname  + "BiomeMap.bmp");
                writer.WriteDestFile();

                //climate.Map = climateSim.BiomeMap2;
                //renderer.ClearGradient();
                //renderer.AddGradientPoint((int)DNDCLIMATE_E.D_WARM_SWAMP, new Color(0x91, 0x2C, 0xEE));
                //renderer.AddGradientPoint((int)DNDCLIMATE_E.D_TEMP_SWAMP, new Color(0x7D, 0x26, 0xCD));
                //renderer.AddGradientPoint((int)DNDCLIMATE_E.D_COLD_SWAMP, new Color(0x55, 0x1A, 0x8B));

                //renderer.AddGradientPoint((int)DNDCLIMATE_E.D_WARM_FOREST, new Color(0, 0xCD, 0));
                //renderer.AddGradientPoint((int)DNDCLIMATE_E.D_TEMP_FOREST, new Color(0, 0x8B, 0));
                //renderer.AddGradientPoint((int)DNDCLIMATE_E.D_COLD_FOREST, new Color(0, 0x64, 0));

                //renderer.AddGradientPoint((int)DNDCLIMATE_E.D_WARM_PLAIN, new Color(0xEE, 0x9A, 0x0));
                //renderer.AddGradientPoint((int)DNDCLIMATE_E.D_TEMP_PLAIN, new Color(0xCD, 0x85, 0x0));
                //renderer.AddGradientPoint((int)DNDCLIMATE_E.D_COLD_PLAIN, new Color(0x8B, 0x5A, 0x0));

                //renderer.AddGradientPoint((int)DNDCLIMATE_E.D_WARM_DESERT, new Color(0xFF, 0xFF, 0x0));
                //renderer.AddGradientPoint((int)DNDCLIMATE_E.D_TEMP_DESERT, new Color(0xEE, 0xEE, 0x0));
                //renderer.AddGradientPoint((int)DNDCLIMATE_E.D_COLD_DESERT, new Color(0xCD, 0xCD, 0x0));

                //renderer.AddGradientPoint((int)DNDCLIMATE_E.D_WARM_HILL, new Color(0xEE, 0x0, 0x0));
                //renderer.AddGradientPoint((int)DNDCLIMATE_E.D_TEMP_HILL, new Color(0xCD, 0x0, 0x0));
                //renderer.AddGradientPoint((int)DNDCLIMATE_E.D_COLD_HILL, new Color(0x8B, 0x0, 0x0));

                //renderer.AddGradientPoint((int)DNDCLIMATE_E.D_WARM_MOUNTAIN, new Color(137, 122, 92));
                //renderer.AddGradientPoint((int)DNDCLIMATE_E.D_TEMP_MOUNTAIN, new Color(137 + 32, 122 + 32, 92 + 32));
                //renderer.AddGradientPoint((int)DNDCLIMATE_E.D_COLD_MOUNTAIN, new Color(137 + 64, 122 + 64, 92 + 64));

                //renderer.AddGradientPoint((int)DNDCLIMATE_E.D_WARM_AQUATIC, new Color(0, 0, 0xEE));
                //renderer.AddGradientPoint((int)DNDCLIMATE_E.D_TEMP_AQUATIC, new Color(0, 0, 0xEE));
                //renderer.AddGradientPoint((int)DNDCLIMATE_E.D_COLD_AQUATIC, new Color(0, 0, 0x8B));
                //renderer.AddGradientPoint((int)DNDCLIMATE_E.D_OCEANICE, new Color(0xBF, 0xBF, 0xBF));
                //renderer.Render();
                //writer.SetSourceImage(image);
                //writer.SetDestFilename("BiomeMap2.bmp");
                //writer.WriteDestFile();
        }

        static float[,] ComputePlanet()
        {
            ////////////////////////////////////////////////////////////////////////////
            // Constants
            //
            // Modify these constants to change the terrain of the planet and to change
            // the boundaries and size of the elevation grid.
            //
            // Note: "Planetary elevation units" range from -1.0 (for the lowest
            // underwater trenches) to +1.0 (for the highest mountain peaks.)
            //

            // Southernmost coordinate of elevation grid.
            const double SOUTH_COORD = -90;

            // Northernmost coordinate of elevation grid.
            const double NORTH_COORD = 90;

            // Westernmost coordinate of elevation grid.
            const double WEST_COORD = -180;

            // Easternmost coordinate of elevation grid.
            const double EAST_COORD = 180;

            // Width of elevation grid, in points.
            const int GRID_WIDTH = 4096 / 8;

            // Height of elevation grid, in points.
            const int GRID_HEIGHT = 2048 / 8;

            // Planet seed.  Change this to generate a different planet.
            int CUR_SEED = worldName.GetHashCode();

            // Circumference of the planet, in meters.
            const double PLANET_CIRCUMFERENCE = 44236800.0;

            // Minimum elevation on the planet, in meters.  This value is approximate.
            const double MIN_ELEV = -8192.0;

            // Maximum elevation on the planet, in meters.  This value is approximate.
            const double MAX_ELEV = 8192.0;

            // Frequency of the planet's continents.  Higher frequency produces smaller,
            // more numerous continents.  This value is measured in radians.
            const double CONTINENT_FREQUENCY = 1.0;

            // Lacunarity of the planet's continents.  Changing this value produces
            // slightly different continents.  For the best results, this value should
            // be random, but close to 2.0.
            const double CONTINENT_LACUNARITY = 2.208984375;

            // Lacunarity of the planet's mountains.  Changing this value produces
            // slightly different mountains.  For the best results, this value should
            // be random, but close to 2.0.
            const double MOUNTAIN_LACUNARITY = 2.142578125;

            // Lacunarity of the planet's hills.  Changing this value produces slightly
            // different hills.  For the best results, this value should be random, but
            // close to 2.0.
            const double HILLS_LACUNARITY = 2.162109375;

            // Lacunarity of the planet's plains.  Changing this value produces slightly
            // different plains.  For the best results, this value should be random, but
            // close to 2.0.
            const double PLAINS_LACUNARITY = 2.314453125;

            // Lacunarity of the planet's badlands.  Changing this value produces
            // slightly different badlands.  For the best results, this value should be
            // random, but close to 2.0.
            const double BADLANDS_LACUNARITY = 2.212890625;

            // Specifies the "twistiness" of the mountains.
            const double MOUNTAINS_TWIST = 1.0;

            // Specifies the "twistiness" of the hills.
            const double HILLS_TWIST = 1.0;

            // Specifies the "twistiness" of the badlands.
            const double BADLANDS_TWIST = 1.0;

            // Specifies the planet's sea level.  This value must be between -1.0
            // (minimum planet elevation) and +1.0 (maximum planet elevation.)
            const double SEA_LEVEL = 0.0;

            // Specifies the level on the planet in which continental shelves appear.
            // This value must be between -1.0 (minimum planet elevation) and +1.0
            // (maximum planet elevation), and must be less than SEA_LEVEL.
            const double SHELF_LEVEL = -0.375;

            // Determines the amount of mountainous terrain that appears on the
            // planet.  Values range from 0.0 (no mountains) to 1.0 (all terrain is
            // covered in mountains).  Mountainous terrain will overlap hilly terrain.
            // Because the badlands terrain may overlap parts of the mountainous
            // terrain, setting MOUNTAINS_AMOUNT to 1.0 may not completely cover the
            // terrain in mountains.
            const double MOUNTAINS_AMOUNT = 0.5;

            // Determines the amount of hilly terrain that appears on the planet.
            // Values range from 0.0 (no hills) to 1.0 (all terrain is covered in
            // hills).  This value must be less than MOUNTAINS_AMOUNT.  Because the
            // mountainous terrain will overlap parts of the hilly terrain, and
            // the badlands terrain may overlap parts of the hilly terrain, setting
            // HILLS_AMOUNT to 1.0 may not completely cover the terrain in hills.
            const double HILLS_AMOUNT = (1.0 + MOUNTAINS_AMOUNT) / 2.0;

            // Determines the amount of badlands terrain that covers the planet.
            // Values range from 0.0 (no badlands) to 1.0 (all terrain is covered in
            // badlands.)  Badlands terrain will overlap any other type of terrain.
            const double BADLANDS_AMOUNT = 0.03125;

            // Offset to apply to the terrain type definition.  Low values (< 1.0) cause
            // the rough areas to appear only at high elevations.  High values (> 2.0)
            // cause the rough areas to appear at any elevation.  The percentage of
            // rough areas on the planet are independent of this value.
            const double TERRAIN_OFFSET = 1.0;

            // Specifies the amount of "glaciation" on the mountains.  This value
            // should be close to 1.0 and greater than 1.0.
            const double MOUNTAIN_GLACIATION = 1.375;

            // Scaling to apply to the base continent elevations, in planetary elevation
            // units.
            const double CONTINENT_HEIGHT_SCALE = (1.0 - SEA_LEVEL) / 4.0;

            // Maximum depth of the rivers, in planetary elevation units.
            const double RIVER_DEPTH = 0.0234375;


            ////////////////////////////////////////////////////////////////////////////
            // Module group: continent definition
            ////////////////////////////////////////////////////////////////////////////

            ////////////////////////////////////////////////////////////////////////////
            // Module subgroup: base continent definition (7 noise modules)
            //
            // This subgroup roughly defines the positions and base elevations of the
            // planet's continents.
            //
            // The "base elevation" is the elevation of the terrain before any terrain
            // features (mountains, hills, etc.) are placed on that terrain.
            //
            // -1.0 represents the lowest elevations and +1.0 represents the highest
            // elevations.
            //

            // 1: [Continent module]: This Perlin-noise module generates the continents.
            //    This noise module has a high number of octaves so that detail is
            //    visible at high zoom levels.
            Perlin baseContinentDef_pe0 = new Perlin();
            baseContinentDef_pe0.Seed = CUR_SEED + 0;
            baseContinentDef_pe0.Frequency = CONTINENT_FREQUENCY;
            baseContinentDef_pe0.Persistence = 0.5;
            baseContinentDef_pe0.Lacunarity = CONTINENT_LACUNARITY;
            baseContinentDef_pe0.OctaveCount = 14;
            baseContinentDef_pe0.Quality = QualityMode.Medium;

            // 2: [Continent-with-ranges module]: Next, a curve module modifies the
            //    output value from the continent module so that very high values appear
            //    near sea level.  This defines the positions of the mountain ranges.
            Curve baseContinentDef_cu = new Curve();
            baseContinentDef_cu[0] = baseContinentDef_pe0;
            baseContinentDef_cu.Add(-2.0000 + SEA_LEVEL, -1.625 + SEA_LEVEL);
            baseContinentDef_cu.Add(-1.0000 + SEA_LEVEL, -1.375 + SEA_LEVEL);
            baseContinentDef_cu.Add(0.0000 + SEA_LEVEL, -0.375 + SEA_LEVEL);
            baseContinentDef_cu.Add(0.0625 + SEA_LEVEL, 0.125 + SEA_LEVEL);
            baseContinentDef_cu.Add(0.1250 + SEA_LEVEL, 0.250 + SEA_LEVEL);
            baseContinentDef_cu.Add(0.2500 + SEA_LEVEL, 1.000 + SEA_LEVEL);
            baseContinentDef_cu.Add(0.5000 + SEA_LEVEL, 0.250 + SEA_LEVEL);
            baseContinentDef_cu.Add(0.7500 + SEA_LEVEL, 0.250 + SEA_LEVEL);
            baseContinentDef_cu.Add(1.0000 + SEA_LEVEL, 0.500 + SEA_LEVEL);
            baseContinentDef_cu.Add(2.0000 + SEA_LEVEL, 0.500 + SEA_LEVEL);

            // 3: [Carver module]: This higher-frequency Perlin-noise module will be
            //    used by subsequent noise modules to carve out chunks from the mountain
            //    ranges within the continent-with-ranges module so that the mountain
            //    ranges will not be complely impassible.
            Perlin baseContinentDef_pe1 = new Perlin();
            baseContinentDef_pe1.Seed = CUR_SEED + 1;
            baseContinentDef_pe1.Frequency = CONTINENT_FREQUENCY * 4.34375;
            baseContinentDef_pe1.Persistence = 0.5;
            baseContinentDef_pe1.Lacunarity = CONTINENT_LACUNARITY;
            baseContinentDef_pe1.OctaveCount = 11;
            baseContinentDef_pe1.Quality = QualityMode.Medium;

            // 4: [Scaled-carver module]: This scale/bias module scales the output
            //    value from the carver module such that it is usually near 1.0.  This
            //    is required for step 5.
            ScaleBias baseContinentDef_sb = new ScaleBias();
            baseContinentDef_sb[0] = baseContinentDef_pe1;
            baseContinentDef_sb.Scale = 0.375;
            baseContinentDef_sb.Bias = 0.625;

            // 5: [Carved-continent module]: This minimum-value module carves out chunks
            //    from the continent-with-ranges module.  It does this by ensuring that
            //    only the minimum of the output values from the scaled-carver module
            //    and the continent-with-ranges module contributes to the output value
            //    of this subgroup.  Most of the time, the minimum-value module will
            //    select the output value from the continents-with-ranges module since
            //    the output value from the scaled-carver module is usually near 1.0.
            //    Occasionally, the output value from the scaled-carver module will be
            //    less than the output value from the continent-with-ranges module, so
            //    in this case, the output value from the scaled-carver module is
            //    selected.
            Min baseContinentDef_mi = new Min();
            baseContinentDef_mi[0] = baseContinentDef_sb;
            baseContinentDef_mi[1] = baseContinentDef_cu;

            // 6: [Clamped-continent module]: Finally, a clamp module modifies the
            //    carved-continent module to ensure that the output value of this
            //    subgroup is between -1.0 and 1.0.
            Clamp baseContinentDef_cl = new Clamp();
            baseContinentDef_cl[0] = baseContinentDef_mi;
            baseContinentDef_cl.Minimum = -1.0;
            baseContinentDef_cl.Maximum = 1.0;

            // 7: [Base-continent-definition subgroup]: Caches the output value from the
            //    clamped-continent module.
            Cache baseContinentDef = new Cache();
            baseContinentDef[0] = baseContinentDef_cl;


            ////////////////////////////////////////////////////////////////////////////
            // Module subgroup: continent definition (5 noise modules)
            //
            // This subgroup warps the output value from the the base-continent-
            // definition subgroup, producing more realistic terrain.
            //
            // Warping the base continent definition produces lumpier terrain with
            // cliffs and rifts.
            //
            // -1.0 represents the lowest elevations and +1.0 represents the highest
            // elevations.
            //

            // 1: [Coarse-turbulence module]: This turbulence module warps the output
            //    value from the base-continent-definition subgroup, adding some coarse
            //    detail to it.
            Turbulence continentDef_tu0 = new Turbulence();
            continentDef_tu0[0] = baseContinentDef;
            continentDef_tu0.Seed = CUR_SEED + 10;
            continentDef_tu0.Frequency = CONTINENT_FREQUENCY * 15.25;
            continentDef_tu0.Power = CONTINENT_FREQUENCY / 113.75;
            continentDef_tu0.Roughness = 13;

            // 2: [Intermediate-turbulence module]: This turbulence module warps the
            //    output value from the coarse-turbulence module.  This turbulence has
            //    a higher frequency, but lower power, than the coarse-turbulence
            //    module, adding some intermediate detail to it.
            Turbulence continentDef_tu1 = new Turbulence();
            continentDef_tu1[0] = continentDef_tu0;
            continentDef_tu1.Seed = CUR_SEED + 11;
            continentDef_tu1.Frequency = CONTINENT_FREQUENCY * 47.25;
            continentDef_tu1.Power = CONTINENT_FREQUENCY / 433.75;
            continentDef_tu1.Roughness = 12;

            // 3: [Warped-base-continent-definition module]: This turbulence module
            //    warps the output value from the intermediate-turbulence module.  This
            //    turbulence has a higher frequency, but lower power, than the
            //    intermediate-turbulence module, adding some fine detail to it.
            Turbulence continentDef_tu2 = new Turbulence();
            continentDef_tu2[0] = continentDef_tu1;
            continentDef_tu2.Seed = CUR_SEED + 12;
            continentDef_tu2.Frequency = CONTINENT_FREQUENCY * 95.25;
            continentDef_tu2.Power = CONTINENT_FREQUENCY / 1019.75;
            continentDef_tu2.Roughness = 11;

            // 4: [Select-turbulence module]: At this stage, the turbulence is applied
            //    to the entire base-continent-definition subgroup, producing some very
            //    rugged, unrealistic coastlines.  This selector module selects the
            //    output values from the (unwarped) base-continent-definition subgroup
            //    and the warped-base-continent-definition module, based on the output
            //    value from the (unwarped) base-continent-definition subgroup.  The
            //    selection boundary is near sea level and has a relatively smooth
            //    transition.  In effect, only the higher areas of the base-continent-
            //    definition subgroup become warped; the underwater and coastal areas
            //    remain unaffected.
            Select continentDef_se = new Select();
            continentDef_se[0] = baseContinentDef;
            continentDef_se[1] = continentDef_tu2;
            continentDef_se.Controller = baseContinentDef;
            continentDef_se.Minimum = SEA_LEVEL - 0.0375;
            continentDef_se.Maximum = SEA_LEVEL + 1000.0375;
            continentDef_se.FallOff = 0.0625;

            // 7: [Continent-definition group]: Caches the output value from the
            //    clamped-continent module.  This is the output value for the entire
            //    continent-definition group.
            Cache continentDef = new Cache();
            continentDef[0] = continentDef_se;


            ////////////////////////////////////////////////////////////////////////////
            // Module group: terrain type definition
            ////////////////////////////////////////////////////////////////////////////

            ////////////////////////////////////////////////////////////////////////////
            // Module subgroup: terrain type definition (3 noise modules)
            //
            // This subgroup defines the positions of the terrain types on the planet.
            //
            // Terrain types include, in order of increasing roughness, plains, hills,
            // and mountains.
            //
            // This subgroup's output value is based on the output value from the
            // continent-definition group.  Rougher terrain mainly appears at higher
            // elevations.
            //
            // -1.0 represents the smoothest terrain types (plains and underwater) and
            // +1.0 represents the roughest terrain types (mountains).
            //

            // 1: [Warped-continent module]: This turbulence module slightly warps the
            //    output value from the continent-definition group.  This prevents the
            //    rougher terrain from appearing exclusively at higher elevations.
            //    Rough areas may now appear in the the ocean, creating rocky islands
            //    and fjords.
            Turbulence terrainTypeDef_tu = new Turbulence();
            terrainTypeDef_tu[0] = continentDef;
            terrainTypeDef_tu.Seed = CUR_SEED + 20;
            terrainTypeDef_tu.Frequency = CONTINENT_FREQUENCY * 18.125;
            terrainTypeDef_tu.Power = CONTINENT_FREQUENCY / 20.59375 * TERRAIN_OFFSET;
            terrainTypeDef_tu.Roughness = 3;

            // 2: [Roughness-probability-shift module]: This terracing module sharpens
            //    the edges of the warped-continent module near sea level and lowers
            //    the slope towards the higher-elevation areas.  This shrinks the areas
            //    in which the rough terrain appears, increasing the "rarity" of rough
            //    terrain.
            Terrace terrainTypeDef_te = new Terrace();
            terrainTypeDef_te[0] = terrainTypeDef_tu;
            terrainTypeDef_te.Add(-1.00);
            terrainTypeDef_te.Add(SHELF_LEVEL + SEA_LEVEL / 2.0);
            terrainTypeDef_te.Add(1.00);

            // 3: [Terrain-type-definition group]: Caches the output value from the
            //    roughness-probability-shift module.  This is the output value for
            //    the entire terrain-type-definition group.
            Cache terrainTypeDef = new Cache();
            terrainTypeDef[0] = terrainTypeDef_te;


            ////////////////////////////////////////////////////////////////////////////
            // Module group: mountainous terrain
            ////////////////////////////////////////////////////////////////////////////

            ////////////////////////////////////////////////////////////////////////////
            // Module subgroup: mountain base definition (9 noise modules)
            //
            // This subgroup generates the base-mountain elevations.  Other subgroups
            // will add the ridges and low areas to the base elevations.
            //
            // -1.0 represents low mountainous terrain and +1.0 represents high
            // mountainous terrain.
            //

            // 1: [Mountain-ridge module]: This ridged-multifractal-noise module
            //    generates the mountain ridges.
            RiggedMultifractal mountainBaseDef_rm0 = new RiggedMultifractal();
            mountainBaseDef_rm0.Seed = CUR_SEED + 30;
            mountainBaseDef_rm0.Frequency = 1723.0;
            mountainBaseDef_rm0.Lacunarity = MOUNTAIN_LACUNARITY;
            mountainBaseDef_rm0.OctaveCount = 4;
            mountainBaseDef_rm0.Quality = QualityMode.Medium;

            // 2: [Scaled-mountain-ridge module]: Next, a scale/bias module scales the
            //    output value from the mountain-ridge module so that its ridges are not
            //    too high.  The reason for this is that another subgroup adds actual
            //    mountainous terrain to these ridges.
            ScaleBias mountainBaseDef_sb0 = new ScaleBias();
            mountainBaseDef_sb0[0] = mountainBaseDef_rm0;
            mountainBaseDef_sb0.Scale = 0.5;
            mountainBaseDef_sb0.Bias = 0.375;

            // 3: [River-valley module]: This ridged-multifractal-noise module generates
            //    the river valleys.  It has a much lower frequency than the mountain-
            //    ridge module so that more mountain ridges will appear outside of the
            //    valleys.  Note that this noise module generates ridged-multifractal
            //    noise using only one octave; this information will be important in the
            //    next step.
            RiggedMultifractal mountainBaseDef_rm1 = new RiggedMultifractal();
            mountainBaseDef_rm1.Seed = CUR_SEED + 31;
            mountainBaseDef_rm1.Frequency = 367.0;
            mountainBaseDef_rm1.Lacunarity = MOUNTAIN_LACUNARITY;
            mountainBaseDef_rm1.OctaveCount = 1;
            mountainBaseDef_rm1.Quality = QualityMode.High;

            // 4: [Scaled-river-valley module]: Next, a scale/bias module applies a
            //    scaling factor of -2.0 to the output value from the river-valley
            //    module.  This stretches the possible elevation values because one-
            //    octave ridged-multifractal noise has a lower range of output values
            //    than multiple-octave ridged-multifractal noise.  The negative scaling
            //    factor inverts the range of the output value, turning the ridges from
            //    the river-valley module into valleys.
            ScaleBias mountainBaseDef_sb1 = new ScaleBias();
            mountainBaseDef_sb1[0] = mountainBaseDef_rm1;
            mountainBaseDef_sb1.Scale = -2.0;
            mountainBaseDef_sb1.Bias = -0.5;

            // 5: [Low-flat module]: This low constant value is used by step 6.
            Const mountainBaseDef_co = new Const();
            mountainBaseDef_co.Value = -1.0;

            // 6: [Mountains-and-valleys module]: This blender module merges the
            //    scaled-mountain-ridge module and the scaled-river-valley module
            //    together.  It causes the low-lying areas of the terrain to become
            //    smooth, and causes the high-lying areas of the terrain to contain
            //    ridges.  To do this, it uses the scaled-river-valley module as the
            //    control module, causing the low-flat module to appear in the lower
            //    areas and causing the scaled-mountain-ridge module to appear in the
            //    higher areas.
            Blend mountainBaseDef_bl = new Blend();
            mountainBaseDef_bl[0] = mountainBaseDef_co;
            mountainBaseDef_bl[1] = mountainBaseDef_sb0;
            mountainBaseDef_bl.Controller = mountainBaseDef_sb1;

            // 7: [Coarse-turbulence module]: This turbulence module warps the output
            //    value from the mountain-and-valleys module, adding some coarse detail
            //    to it.
            Turbulence mountainBaseDef_tu0 = new Turbulence();
            mountainBaseDef_tu0[0] = mountainBaseDef_bl;
            mountainBaseDef_tu0.Seed = CUR_SEED + 32;
            mountainBaseDef_tu0.Frequency = 1337.0;
            mountainBaseDef_tu0.Power = 1.0 / 6730.0 * MOUNTAINS_TWIST;
            mountainBaseDef_tu0.Roughness = 4;

            // 8: [Warped-mountains-and-valleys module]: This turbulence module warps
            //    the output value from the coarse-turbulence module.  This turbulence
            //    has a higher frequency, but lower power, than the coarse-turbulence
            //    module, adding some fine detail to it.
            Turbulence mountainBaseDef_tu1 = new Turbulence();
            mountainBaseDef_tu1[0] = mountainBaseDef_tu0;
            mountainBaseDef_tu1.Seed = CUR_SEED + 33;
            mountainBaseDef_tu1.Frequency = 21221.0;
            mountainBaseDef_tu1.Power = 1.0 / 120157.0 * MOUNTAINS_TWIST;
            mountainBaseDef_tu1.Roughness = 6;

            // 9: [Mountain-base-definition subgroup]: Caches the output value from the
            //    warped-mountains-and-valleys module.
            Cache mountainBaseDef = new Cache();
            mountainBaseDef[0] = mountainBaseDef_tu1;


            ////////////////////////////////////////////////////////////////////////////
            // Module subgroup: high mountainous terrain = 5 noise modules)
            //
            // This subgroup generates the mountainous terrain that appears at high
            // elevations within the mountain ridges.
            //
            // -1.0 represents the lowest elevations and +1.0 represents the highest
            // elevations.
            //

            // 1: [Mountain-basis-0 module]: This ridged-multifractal-noise module,
            //    along with the mountain-basis-1 module, generates the individual
            //    mountains.
            RiggedMultifractal mountainousHigh_rm0 = new RiggedMultifractal();
            mountainousHigh_rm0.Seed = CUR_SEED + 40;
            mountainousHigh_rm0.Frequency = 2371.0;
            mountainousHigh_rm0.Lacunarity = MOUNTAIN_LACUNARITY;
            mountainousHigh_rm0.OctaveCount = 3;
            mountainousHigh_rm0.Quality = QualityMode.Medium;

            // 2: [Mountain-basis-1 module]: This ridged-multifractal-noise module,
            //    along with the mountain-basis-0 module, generates the individual
            //    mountains.
            RiggedMultifractal mountainousHigh_rm1 = new RiggedMultifractal();
            mountainousHigh_rm1.Seed = CUR_SEED + 41;
            mountainousHigh_rm1.Frequency = 2341.0;
            mountainousHigh_rm1.Lacunarity = MOUNTAIN_LACUNARITY;
            mountainousHigh_rm1.OctaveCount = 3;
            mountainousHigh_rm1.Quality = QualityMode.Medium;

            // 3: [High-mountains module]: Next, a maximum-value module causes more
            //    mountains to appear at the expense of valleys.  It does this by
            //    ensuring that only the maximum of the output values from the two
            //    ridged-multifractal-noise modules contribute to the output value of
            //    this subgroup.
            Max mountainousHigh_ma = new Max();
            mountainousHigh_ma[0] = mountainousHigh_rm0;
            mountainousHigh_ma[1] = mountainousHigh_rm1;

            // 4: [Warped-high-mountains module]: This turbulence module warps the
            //    output value from the high-mountains module, adding some detail to it.
            Turbulence mountainousHigh_tu = new Turbulence();
            mountainousHigh_tu[0] = mountainousHigh_ma;
            mountainousHigh_tu.Seed = CUR_SEED + 42;
            mountainousHigh_tu.Frequency = 31511.0;
            mountainousHigh_tu.Power = 1.0 / 180371.0 * MOUNTAINS_TWIST;
            mountainousHigh_tu.Roughness = 4;

            // 5: [High-mountainous-terrain subgroup]: Caches the output value from the
            //    warped-high-mountains module.
            Cache mountainousHigh = new Cache();
            mountainousHigh[0] = mountainousHigh_tu;


            ////////////////////////////////////////////////////////////////////////////
            // Module subgroup: low mountainous terrain (4 noise modules)
            //
            // This subgroup generates the mountainous terrain that appears at low
            // elevations within the river valleys.
            //
            // -1.0 represents the lowest elevations and +1.0 represents the highest
            // elevations.
            //

            // 1: [Lowland-basis-0 module]: This ridged-multifractal-noise module,
            //    along with the lowland-basis-1 module, produces the low mountainous
            //    terrain.
            RiggedMultifractal mountainousLow_rm0 = new RiggedMultifractal();
            mountainousLow_rm0.Seed = CUR_SEED + 50;
            mountainousLow_rm0.Frequency = 1381.0;
            mountainousLow_rm0.Lacunarity = MOUNTAIN_LACUNARITY;
            mountainousLow_rm0.OctaveCount = 8;
            mountainousLow_rm0.Quality = QualityMode.High;

            // 1: [Lowland-basis-1 module]: This ridged-multifractal-noise module,
            //    along with the lowland-basis-0 module, produces the low mountainous
            //    terrain.
            RiggedMultifractal mountainousLow_rm1 = new RiggedMultifractal();
            mountainousLow_rm1.Seed = CUR_SEED + 51;
            mountainousLow_rm1.Frequency = 1427.0;
            mountainousLow_rm1.Lacunarity = MOUNTAIN_LACUNARITY;
            mountainousLow_rm1.OctaveCount = 8;
            mountainousLow_rm1.Quality = QualityMode.High;

            // 3: [Low-mountainous-terrain module]: This multiplication module combines
            //    the output values from the two ridged-multifractal-noise modules.
            //    This causes the following to appear in the resulting terrain:
            //    - Cracks appear when two negative output values are multiplied
            //      together.
            //    - Flat areas appear when a positive and a negative output value are
            //      multiplied together.
            //    - Ridges appear when two positive output values are multiplied
            //      together.
            Multiply mountainousLow_mu = new Multiply();
            mountainousLow_mu[0] = mountainousLow_rm0;
            mountainousLow_mu[1] = mountainousLow_rm1;

            // 4: [Low-mountainous-terrain subgroup]: Caches the output value from the
            //    low-moutainous-terrain module.
            Cache mountainousLow = new Cache();
            mountainousLow[0] = mountainousLow_mu;


            ////////////////////////////////////////////////////////////////////////////
            // Module subgroup: mountainous terrain (7 noise modules)
            //
            // This subgroup generates the final mountainous terrain by combining the
            // high-mountainous-terrain subgroup with the low-mountainous-terrain
            // subgroup.
            //
            // -1.0 represents the lowest elevations and +1.0 represents the highest
            // elevations.
            //

            // 1: [Scaled-low-mountainous-terrain module]: First, this scale/bias module
            //    scales the output value from the low-mountainous-terrain subgroup to a
            //    very low value and biases it towards -1.0.  This results in the low
            //    mountainous areas becoming more-or-less flat with little variation.
            //    This will also result in the low mountainous areas appearing at the
            //    lowest elevations in this subgroup.
            ScaleBias mountainousTerrain_sb0 = new ScaleBias();
            mountainousTerrain_sb0[0] = mountainousLow;
            mountainousTerrain_sb0.Scale = 0.03125;
            mountainousTerrain_sb0.Bias = -0.96875;

            // 2: [Scaled-high-mountainous-terrain module]: Next, this scale/bias module
            //    scales the output value from the high-mountainous-terrain subgroup to
            //    1/4 of its initial value and biases it so that its output value is
            //    usually positive.
            ScaleBias mountainousTerrain_sb1 = new ScaleBias();
            mountainousTerrain_sb1[0] = mountainousHigh;
            mountainousTerrain_sb1.Scale = 0.25;
            mountainousTerrain_sb1.Bias = 0.25;

            // 3: [Added-high-mountainous-terrain module]: This addition module adds the
            //    output value from the scaled-high-mountainous-terrain module to the
            //    output value from the mountain-base-definition subgroup.  Mountains
            //    now appear all over the terrain.
            Add mountainousTerrain_ad = new Add();
            mountainousTerrain_ad[0] = mountainousTerrain_sb1;
            mountainousTerrain_ad[1] = mountainBaseDef;

            // 4: [Combined-mountainous-terrain module]: Note that at this point, the
            //    entire terrain is covered in high mountainous terrain, even at the low
            //    elevations.  To make sure the mountains only appear at the higher
            //    elevations, this selector module causes low mountainous terrain to
            //    appear at the low elevations (within the valleys) and the high
            //    mountainous terrain to appear at the high elevations (within the
            //    ridges.)  To do this, this noise module selects the output value from
            //    the added-high-mountainous-terrain module if the output value from the
            //    mountain-base-definition subgroup is higher than a set amount.
            //    Otherwise, this noise module selects the output value from the scaled-
            //    low-mountainous-terrain module.
            Select mountainousTerrain_se = new Select();
            mountainousTerrain_se[0] = mountainousTerrain_sb0;
            mountainousTerrain_se[1] = mountainousTerrain_ad;
            mountainousTerrain_se.Controller = mountainBaseDef;
            mountainousTerrain_se.Minimum = -0.5;
            mountainousTerrain_se.Maximum = 999.5;
            mountainousTerrain_se.FallOff = 0.5;

            // 5: [Scaled-mountainous-terrain-module]: This scale/bias module slightly
            //    reduces the range of the output value from the combined-mountainous-
            //    terrain module, decreasing the heights of the mountain peaks.
            ScaleBias mountainousTerrain_sb2 = new ScaleBias();
            mountainousTerrain_sb2[0] = mountainousTerrain_se;
            mountainousTerrain_sb2.Scale = 0.8;
            mountainousTerrain_sb2.Bias = 0.0;

            // 6: [Glaciated-mountainous-terrain-module]: This exponential-curve module
            //    applies an exponential curve to the output value from the scaled-
            //    mountainous-terrain module.  This causes the slope of the mountains to
            //    smoothly increase towards higher elevations, as if a glacier grinded
            //    out those mountains.  This exponential-curve module expects the output
            //    value to range from -1.0 to +1.0.
            Exponent mountainousTerrain_ex = new Exponent();
            mountainousTerrain_ex[0] = mountainousTerrain_sb2;
            mountainousTerrain_ex.Value = MOUNTAIN_GLACIATION;

            // 7: [Mountainous-terrain group]: Caches the output value from the
            //    glaciated-mountainous-terrain module.  This is the output value for
            //    the entire mountainous-terrain group.
            Cache mountainousTerrain = new Cache();
            mountainousTerrain[0] = mountainousTerrain_ex;


            ////////////////////////////////////////////////////////////////////////////
            // Module group: hilly terrain
            ////////////////////////////////////////////////////////////////////////////

            ////////////////////////////////////////////////////////////////////////////
            // Module subgroup: hilly terrain (11 noise modules)
            //
            // This subgroup generates the hilly terrain.
            //
            // -1.0 represents the lowest elevations and +1.0 represents the highest
            // elevations.
            //

            // 1: [Hills module]: This billow-noise module generates the hills.
            Billow hillyTerrain_bi = new Billow();
            hillyTerrain_bi.Seed = CUR_SEED + 60;
            hillyTerrain_bi.Frequency = 1663.0;
            hillyTerrain_bi.Persistence = 0.5;
            hillyTerrain_bi.Lacunarity = HILLS_LACUNARITY;
            hillyTerrain_bi.OctaveCount = 6;
            hillyTerrain_bi.Quality = QualityMode.High;

            // 2: [Scaled-hills module]: Next, a scale/bias module scales the output
            //    value from the hills module so that its hilltops are not too high.
            //    The reason for this is that these hills are eventually added to the
            //    river valleys (see below.)
            ScaleBias hillyTerrain_sb0 = new ScaleBias();
            hillyTerrain_sb0[0] = hillyTerrain_bi;
            hillyTerrain_sb0.Scale = 0.5;
            hillyTerrain_sb0.Bias = 0.5;

            // 3: [River-valley module]: This ridged-multifractal-noise module generates
            //    the river valleys.  It has a much lower frequency so that more hills
            //    will appear in between the valleys.  Note that this noise module
            //    generates ridged-multifractal noise using only one octave; this
            //    information will be important in the next step.
            RiggedMultifractal hillyTerrain_rm = new RiggedMultifractal();
            hillyTerrain_rm.Seed = CUR_SEED + 61;
            hillyTerrain_rm.Frequency = 367.5;
            hillyTerrain_rm.Lacunarity = HILLS_LACUNARITY;
            hillyTerrain_rm.Quality = QualityMode.High;
            hillyTerrain_rm.OctaveCount = 1;

            // 4: [Scaled-river-valley module]: Next, a scale/bias module applies a
            //    scaling factor of -2.0 to the output value from the river-valley
            //    module.  This stretches the possible elevation values because one-
            //    octave ridged-multifractal noise has a lower range of output values
            //    than multiple-octave ridged-multifractal noise.  The negative scaling
            //    factor inverts the range of the output value, turning the ridges from
            //    the river-valley module into valleys.
            ScaleBias hillyTerrain_sb1 = new ScaleBias();
            hillyTerrain_sb1[0] = hillyTerrain_rm;
            hillyTerrain_sb1.Scale = -2.0;
            hillyTerrain_sb1.Bias = -0.5;

            // 5: [Low-flat module]: This low constant value is used by step 6.
            Const hillyTerrain_co = new Const();
            hillyTerrain_co.Value = -1.0;

            // 6: [Mountains-and-valleys module]: This blender module merges the
            //    scaled-hills module and the scaled-river-valley module together.  It
            //    causes the low-lying areas of the terrain to become smooth, and causes
            //    the high-lying areas of the terrain to contain hills.  To do this, it
            //    uses the scaled-hills module as the control module, causing the low-
            //    flat module to appear in the lower areas and causing the scaled-river-
            //    valley module to appear in the higher areas.
            Blend hillyTerrain_bl = new Blend();
            hillyTerrain_bl[0] = hillyTerrain_co;
            hillyTerrain_bl[1] = hillyTerrain_sb1;
            hillyTerrain_bl.Controller = hillyTerrain_sb0;

            // 7: [Scaled-hills-and-valleys module]: This scale/bias module slightly
            //    reduces the range of the output value from the hills-and-valleys
            //    module, decreasing the heights of the hilltops.
            ScaleBias hillyTerrain_sb2 = new ScaleBias();
            hillyTerrain_sb2[0] = hillyTerrain_bl;
            hillyTerrain_sb2.Scale = 0.75;
            hillyTerrain_sb2.Bias = -0.25;

            // 8: [Increased-slope-hilly-terrain module]: To increase the hill slopes at
            //    higher elevations, this exponential-curve module applies an
            //    exponential curve to the output value the scaled-hills-and-valleys
            //    module.  This exponential-curve module expects the input value to
            //    range from -1.0 to 1.0.
            Exponent hillyTerrain_ex = new Exponent();
            hillyTerrain_ex[0] = hillyTerrain_sb2;
            hillyTerrain_ex.Value = 1.375;

            // 9: [Coarse-turbulence module]: This turbulence module warps the output
            //    value from the increased-slope-hilly-terrain module, adding some
            //    coarse detail to it.
            Turbulence hillyTerrain_tu0 = new Turbulence();
            hillyTerrain_tu0[0] = hillyTerrain_ex;
            hillyTerrain_tu0.Seed = CUR_SEED + 62;
            hillyTerrain_tu0.Frequency = 1531.0;
            hillyTerrain_tu0.Power = 1.0 / 16921.0 * HILLS_TWIST;
            hillyTerrain_tu0.Roughness = 4;

            // 10: [Warped-hilly-terrain module]: This turbulence module warps the
            //     output value from the coarse-turbulence module.  This turbulence has
            //     a higher frequency, but lower power, than the coarse-turbulence
            //     module, adding some fine detail to it.
            Turbulence hillyTerrain_tu1 = new Turbulence();
            hillyTerrain_tu1[0] = hillyTerrain_tu0;
            hillyTerrain_tu1.Seed = CUR_SEED + 63;
            hillyTerrain_tu1.Frequency = 21617.0;
            hillyTerrain_tu1.Power = 1.0 / 117529.0 * HILLS_TWIST;
            hillyTerrain_tu1.Roughness = 6;

            // 11: [Hilly-terrain group]: Caches the output value from the warped-hilly-
            //     terrain module.  This is the output value for the entire hilly-
            //     terrain group.
            Cache hillyTerrain = new Cache();
            hillyTerrain[0] = hillyTerrain_tu1;


            ////////////////////////////////////////////////////////////////////////////
            // Module group: plains terrain
            ////////////////////////////////////////////////////////////////////////////

            ////////////////////////////////////////////////////////////////////////////
            // Module subgroup: plains terrain (7 noise modules)
            //
            // This subgroup generates the plains terrain.
            //
            // Because this subgroup will eventually be flattened considerably, the
            // types and combinations of noise modules that generate the plains are not
            // really that important; they only need to "look" interesting.
            //
            // -1.0 represents the lowest elevations and +1.0 represents the highest
            // elevations.
            //

            // 1: [Plains-basis-0 module]: This billow-noise module, along with the
            //    plains-basis-1 module, produces the plains.
            Billow plainsTerrain_bi0 = new Billow();
            plainsTerrain_bi0.Seed = CUR_SEED + 70;
            plainsTerrain_bi0.Frequency = 1097.5;
            plainsTerrain_bi0.Persistence = 0.5;
            plainsTerrain_bi0.Lacunarity = PLAINS_LACUNARITY;
            plainsTerrain_bi0.OctaveCount = 8;
            plainsTerrain_bi0.Quality = QualityMode.High;

            // 2: [Positive-plains-basis-0 module]: This scale/bias module makes the
            //    output value from the plains-basis-0 module positive since this output
            //    value will be multiplied together with the positive-plains-basis-1
            //    module.
            ScaleBias plainsTerrain_sb0 = new ScaleBias();
            plainsTerrain_sb0[0] = plainsTerrain_bi0;
            plainsTerrain_sb0.Scale = 0.5;
            plainsTerrain_sb0.Bias = 0.5;

            // 3: [Plains-basis-1 module]: This billow-noise module, along with the
            //    plains-basis-2 module, produces the plains.
            Billow plainsTerrain_bi1 = new Billow();
            plainsTerrain_bi1.Seed = CUR_SEED + 71;
            plainsTerrain_bi1.Frequency = 1319.5;
            plainsTerrain_bi1.Persistence = 0.5;
            plainsTerrain_bi1.Lacunarity = PLAINS_LACUNARITY;
            plainsTerrain_bi1.OctaveCount = 8;
            plainsTerrain_bi1.Quality = QualityMode.High;

            // 4: [Positive-plains-basis-1 module]: This scale/bias module makes the
            //    output value from the plains-basis-1 module positive since this output
            //    value will be multiplied together with the positive-plains-basis-0
            //    module.
            ScaleBias plainsTerrain_sb1 = new ScaleBias();
            plainsTerrain_sb1[0] = plainsTerrain_bi1;
            plainsTerrain_sb1.Scale = 0.5;
            plainsTerrain_sb1.Bias = 0.5;

            // 5: [Combined-plains-basis module]: This multiplication module combines
            //    the two plains basis modules together.
            Multiply plainsTerrain_mu = new Multiply();
            plainsTerrain_mu[0] = plainsTerrain_sb0;
            plainsTerrain_mu[1] = plainsTerrain_sb1;

            // 6: [Rescaled-plains-basis module]: This scale/bias module maps the output
            //    value that ranges from 0.0 to 1.0 back to a value that ranges from
            //    -1.0 to +1.0.
            ScaleBias plainsTerrain_sb2 = new ScaleBias();
            plainsTerrain_sb2[0] = plainsTerrain_mu;
            plainsTerrain_sb2.Scale = 2.0;
            plainsTerrain_sb2.Bias = -1.0;

            // 7: [Plains-terrain group]: Caches the output value from the rescaled-
            //    plains-basis module.  This is the output value for the entire plains-
            //    terrain group.
            Cache plainsTerrain = new Cache();
            plainsTerrain[0] = plainsTerrain_sb2;


            ////////////////////////////////////////////////////////////////////////////
            // Module group: badlands terrain
            ////////////////////////////////////////////////////////////////////////////

            ////////////////////////////////////////////////////////////////////////////
            // Module subgroup: badlands sand (6 noise modules)
            //
            // This subgroup generates the sandy terrain for the badlands.
            //
            // -1.0 represents the lowest elevations and +1.0 represents the highest
            // elevations.
            //

            // 1: [Sand-dunes module]: This ridged-multifractal-noise module generates
            //    sand dunes.  This ridged-multifractal noise is generated with a single
            //    octave, which makes very smooth dunes.
            RiggedMultifractal badlandsSand_rm = new RiggedMultifractal();
            badlandsSand_rm.Seed = CUR_SEED + 80;
            badlandsSand_rm.Frequency = 6163.5;
            badlandsSand_rm.Lacunarity = BADLANDS_LACUNARITY;
            badlandsSand_rm.Quality = QualityMode.High;
            badlandsSand_rm.OctaveCount = 1;

            // 2: [Scaled-sand-dunes module]: This scale/bias module shrinks the dune
            //    heights by a small amount.  This is necessary so that the subsequent
            //    noise modules in this subgroup can add some detail to the dunes.
            ScaleBias badlandsSand_sb0 = new ScaleBias();
            badlandsSand_sb0[0] = badlandsSand_rm;
            badlandsSand_sb0.Scale = 0.875;
            badlandsSand_sb0.Bias = 0.0;

            // 3: [Dune-detail module]: This noise module uses Voronoi polygons to
            //    generate the detail to add to the dunes.  By enabling the distance
            //    algorithm, small polygonal pits are generated; the edges of the pits
            //    are joined to the edges of nearby pits.
            Voronoi badlandsSand_vo = new Voronoi();
            badlandsSand_vo.Seed = CUR_SEED + 81;
            badlandsSand_vo.Frequency = 16183.25;
            badlandsSand_vo.Displacement = 0.0;
            badlandsSand_vo.UseDistance = true;

            // 4: [Scaled-dune-detail module]: This scale/bias module shrinks the dune
            //    details by a large amount.  This is necessary so that the subsequent
            //    noise modules in this subgroup can add this detail to the sand-dunes
            //    module.
            ScaleBias badlandsSand_sb1 = new ScaleBias();
            badlandsSand_sb1[0] = badlandsSand_vo;
            badlandsSand_sb1.Scale = 0.25;
            badlandsSand_sb1.Bias = 0.25;

            // 5: [Dunes-with-detail module]: This addition module combines the scaled-
            //    sand-dunes module with the scaled-dune-detail module.
            Add badlandsSand_ad = new Add();
            badlandsSand_ad[0] = badlandsSand_sb0;
            badlandsSand_ad[1] = badlandsSand_sb1;

            // 6: [Badlands-sand subgroup]: Caches the output value from the dunes-with-
            //    detail module.
            Cache badlandsSand = new Cache();
            badlandsSand[0] = badlandsSand_ad;


            ////////////////////////////////////////////////////////////////////////////
            // Module subgroup: badlands cliffs (7 noise modules)
            //
            // This subgroup generates the cliffs for the badlands.
            //
            // -1.0 represents the lowest elevations and +1.0 represents the highest
            // elevations.
            //

            // 1: [Cliff-basis module]: This Perlin-noise module generates some coherent
            //    noise that will be used to generate the cliffs.
            Perlin badlandsCliffs_pe = new Perlin();
            badlandsCliffs_pe.Seed = CUR_SEED + 90;
            badlandsCliffs_pe.Frequency = CONTINENT_FREQUENCY * 839.0;
            badlandsCliffs_pe.Persistence = 0.5;
            badlandsCliffs_pe.Lacunarity = BADLANDS_LACUNARITY;
            badlandsCliffs_pe.OctaveCount = 6;
            badlandsCliffs_pe.Quality = QualityMode.Medium;

            // 2: [Cliff-shaping module]: Next, this curve module applies a curve to the
            //    output value from the cliff-basis module.  This curve is initially
            //    very shallow, but then its slope increases sharply.  At the highest
            //    elevations, the curve becomes very flat again.  This produces the
            //    stereotypical Utah-style desert cliffs.
            Curve badlandsCliffs_cu = new Curve();
            badlandsCliffs_cu[0] = badlandsCliffs_pe;
            badlandsCliffs_cu.Add(-2.0000, -2.0000);
            badlandsCliffs_cu.Add(-1.0000, -1.2500);
            badlandsCliffs_cu.Add(-0.0000, -0.7500);
            badlandsCliffs_cu.Add(0.5000, -0.2500);
            badlandsCliffs_cu.Add(0.6250, 0.8750);
            badlandsCliffs_cu.Add(0.7500, 1.0000);
            badlandsCliffs_cu.Add(2.0000, 1.2500);

            // 3: [Clamped-cliffs module]: This clamping module makes the tops of the
            //    cliffs very flat by clamping the output value from the cliff-shaping
            //    module so that the tops of the cliffs are very flat.
            Clamp badlandsCliffs_cl = new Clamp();
            badlandsCliffs_cl[0] = badlandsCliffs_cu;
            badlandsCliffs_cl.Minimum = -999.125;
            badlandsCliffs_cl.Maximum = 0.875;

            // 4: [Terraced-cliffs module]: Next, this terracing module applies some
            //    terraces to the clamped-cliffs module in the lower elevations before
            //    the sharp cliff transition.
            Terrace badlandsCliffs_te = new Terrace();
            badlandsCliffs_te[0] = badlandsCliffs_cl;
            badlandsCliffs_te.Add(-1.0000);
            badlandsCliffs_te.Add(-0.8750);
            badlandsCliffs_te.Add(-0.7500);
            badlandsCliffs_te.Add(-0.5000);
            badlandsCliffs_te.Add(0.0000);
            badlandsCliffs_te.Add(1.0000);

            // 5: [Coarse-turbulence module]: This turbulence module warps the output
            //    value from the terraced-cliffs module, adding some coarse detail to
            //    it.
            Turbulence badlandsCliffs_tu0 = new Turbulence();
            badlandsCliffs_tu0.Seed = CUR_SEED + 91;
            badlandsCliffs_tu0[0] = badlandsCliffs_te;
            badlandsCliffs_tu0.Frequency = 16111.0;
            badlandsCliffs_tu0.Power = 1.0 / 141539.0 * BADLANDS_TWIST;
            badlandsCliffs_tu0.Roughness = 3;

            // 6: [Warped-cliffs module]: This turbulence module warps the output value
            //    from the coarse-turbulence module.  This turbulence has a higher
            //    frequency, but lower power, than the coarse-turbulence module, adding
            //    some fine detail to it.
            Turbulence badlandsCliffs_tu1 = new Turbulence();
            badlandsCliffs_tu1.Seed = CUR_SEED + 92;
            badlandsCliffs_tu1[0] = badlandsCliffs_tu0;
            badlandsCliffs_tu1.Frequency = 36107.0;
            badlandsCliffs_tu1.Power = 1.0 / 211543.0 * BADLANDS_TWIST;
            badlandsCliffs_tu1.Roughness = 3;

            // 7: [Badlands-cliffs subgroup]: Caches the output value from the warped-
            //    cliffs module.
            Cache badlandsCliffs = new Cache();
            badlandsCliffs[0] = badlandsCliffs_tu1;


            ////////////////////////////////////////////////////////////////////////////
            // Module subgroup: badlands terrain (3 noise modules)
            //
            // Generates the final badlands terrain.
            //
            // Using a scale/bias module, the badlands sand is flattened considerably,
            // then the sand elevations are lowered to around -1.0.  The maximum value
            // from the flattened sand module and the cliff module contributes to the
            // final elevation.  This causes sand to appear at the low elevations since
            // the sand is slightly higher than the cliff base.
            //
            // -1.0 represents the lowest elevations and +1.0 represents the highest
            // elevations.
            //

            // 1: [Scaled-sand-dunes module]: This scale/bias module considerably
            //    flattens the output value from the badlands-sands subgroup and lowers
            //    this value to near -1.0.
            ScaleBias badlandsTerrain_sb = new ScaleBias();
            badlandsTerrain_sb[0] = badlandsSand;
            badlandsTerrain_sb.Scale = 0.25;
            badlandsTerrain_sb.Bias = -0.75;

            // 2: [Dunes-and-cliffs module]: This maximum-value module causes the dunes
            //    to appear in the low areas and the cliffs to appear in the high areas.
            //    It does this by selecting the maximum of the output values from the
            //    scaled-sand-dunes module and the badlands-cliffs subgroup.
            Max badlandsTerrain_ma = new Max();
            badlandsTerrain_ma[0] = badlandsCliffs;
            badlandsTerrain_ma[1] = badlandsTerrain_sb;

            // 3: [Badlands-terrain group]: Caches the output value from the dunes-and-
            //    cliffs module.  This is the output value for the entire badlands-
            //    terrain group.
            Cache badlandsTerrain = new Cache();
            badlandsTerrain[0] = badlandsTerrain_ma;


            ////////////////////////////////////////////////////////////////////////////
            // Module group: river positions
            ////////////////////////////////////////////////////////////////////////////

            ////////////////////////////////////////////////////////////////////////////
            // Module subgroup: river positions (7 noise modules)
            //
            // This subgroup generates the river positions.
            //
            // -1.0 represents the lowest elevations and +1.0 represents the highest
            // elevations.
            //

            // 1: [Large-river-basis module]: This ridged-multifractal-noise module
            //    creates the large, deep rivers.
            RiggedMultifractal riverPositions_rm0 = new RiggedMultifractal();
            riverPositions_rm0.Seed = CUR_SEED + 100;
            riverPositions_rm0.Frequency = 18.75;
            riverPositions_rm0.Lacunarity = CONTINENT_LACUNARITY;
            riverPositions_rm0.OctaveCount = 1;
            riverPositions_rm0.Quality = QualityMode.High;

            // 2: [Large-river-curve module]: This curve module applies a curve to the
            //    output value from the large-river-basis module so that the ridges
            //    become inverted.  This creates the rivers.  This curve also compresses
            //    the edge of the rivers, producing a sharp transition from the land to
            //    the river bottom.
            Curve riverPositions_cu0 = new Curve();
            riverPositions_cu0[0] = riverPositions_rm0;
            riverPositions_cu0.Add(-2.000, 2.000);
            riverPositions_cu0.Add(-1.000, 1.000);
            riverPositions_cu0.Add(-0.125, 0.875);
            riverPositions_cu0.Add(0.000, -1.000);
            riverPositions_cu0.Add(1.000, -1.500);
            riverPositions_cu0.Add(2.000, -2.000);

            /// 3: [Small-river-basis module]: This ridged-multifractal-noise module
            //     creates the small, shallow rivers.
            RiggedMultifractal riverPositions_rm1 = new RiggedMultifractal();
            riverPositions_rm1.Seed = CUR_SEED + 101;
            riverPositions_rm1.Frequency = 43.25;
            riverPositions_rm1.Lacunarity = CONTINENT_LACUNARITY;
            riverPositions_rm1.OctaveCount = 1;
            riverPositions_rm1.Quality = QualityMode.High;

            // 4: [Small-river-curve module]: This curve module applies a curve to the
            //    output value from the small-river-basis module so that the ridges
            //    become inverted.  This creates the rivers.  This curve also compresses
            //    the edge of the rivers, producing a sharp transition from the land to
            //    the river bottom.
            Curve riverPositions_cu1 = new Curve();
            riverPositions_cu1[0] = riverPositions_rm1;
            riverPositions_cu1.Add(-2.000, 2.0000);
            riverPositions_cu1.Add(-1.000, 1.5000);
            riverPositions_cu1.Add(-0.125, 1.4375);
            riverPositions_cu1.Add(0.000, 0.5000);
            riverPositions_cu1.Add(1.000, 0.2500);
            riverPositions_cu1.Add(2.000, 0.0000);

            // 5: [Combined-rivers module]: This minimum-value module causes the small
            //    rivers to cut into the large rivers.  It does this by selecting the
            //    minimum output values from the large-river-curve module and the small-
            //    river-curve module.
            Min riverPositions_mi = new Min();
            riverPositions_mi[0] = riverPositions_cu0;
            riverPositions_mi[1] = riverPositions_cu1;

            // 6: [Warped-rivers module]: This turbulence module warps the output value
            //    from the combined-rivers module, which twists the rivers.  The high
            //    roughness produces less-smooth rivers.
            Turbulence riverPositions_tu = new Turbulence();
            riverPositions_tu[0] = riverPositions_mi;
            riverPositions_tu.Seed = CUR_SEED + 102;
            riverPositions_tu.Frequency = 9.25;
            riverPositions_tu.Power = 1.0 / 57.75;
            riverPositions_tu.Roughness = 6;

            // 7: [River-positions group]: Caches the output value from the warped-
            //    rivers module.  This is the output value for the entire river-
            //    positions group.
            Cache riverPositions = new Cache();
            riverPositions[0] = riverPositions_tu;


            ////////////////////////////////////////////////////////////////////////////
            // Module group: scaled mountainous terrain
            ////////////////////////////////////////////////////////////////////////////

            ////////////////////////////////////////////////////////////////////////////
            // Module subgroup: scaled mountainous terrain (6 noise modules)
            //
            // This subgroup scales the output value from the mountainous-terrain group
            // so that it can be added to the elevation defined by the continent-
            // definition group.
            //
            // This subgroup scales the output value such that it is almost always
            // positive.  This is done so that a negative elevation does not get applied
            // to the continent-definition group, preventing parts of that group from
            // having negative terrain features "stamped" into it.
            //
            // The output value from this module subgroup is measured in planetary
            // elevation units (-1.0 for the lowest underwater trenches and +1.0 for the
            // highest mountain peaks.)
            //

            // 1: [Base-scaled-mountainous-terrain module]: This scale/bias module
            //    scales the output value from the mountainous-terrain group so that the
            //    output value is measured in planetary elevation units.
            ScaleBias scaledMountainousTerrain_sb0 = new ScaleBias();
            scaledMountainousTerrain_sb0[0] = mountainousTerrain;
            scaledMountainousTerrain_sb0.Scale = 0.125;
            scaledMountainousTerrain_sb0.Bias = 0.125;

            // 2: [Base-peak-modulation module]: At this stage, most mountain peaks have
            //    roughly the same elevation.  This Perlin-noise module generates some
            //    random values that will be used by subsequent noise modules to
            //    randomly change the elevations of the mountain peaks.
            Perlin scaledMountainousTerrain_pe = new Perlin();
            scaledMountainousTerrain_pe.Seed = CUR_SEED + 110;
            scaledMountainousTerrain_pe.Frequency = 14.5;
            scaledMountainousTerrain_pe.Persistence = 0.5;
            scaledMountainousTerrain_pe.Lacunarity = MOUNTAIN_LACUNARITY;
            scaledMountainousTerrain_pe.OctaveCount = 6;
            scaledMountainousTerrain_pe.Quality = QualityMode.Medium;

            // 3: [Peak-modulation module]: This exponential-curve module applies an
            //    exponential curve to the output value from the base-peak-modulation
            //    module.  This produces a small number of high values and a much larger
            //    number of low values.  This means there will be a few peaks with much
            //    higher elevations than the majority of the peaks, making the terrain
            //    features more varied.
            Exponent scaledMountainousTerrain_ex = new Exponent();
            scaledMountainousTerrain_ex[0] = scaledMountainousTerrain_pe;
            scaledMountainousTerrain_ex.Value = 1.25;

            // 4: [Scaled-peak-modulation module]: This scale/bias module modifies the
            //    range of the output value from the peak-modulation module so that it
            //    can be used as the modulator for the peak-height-multiplier module.
            //    It is important that this output value is not much lower than 1.0.
            ScaleBias scaledMountainousTerrain_sb1 = new ScaleBias();
            scaledMountainousTerrain_sb1[0] =
              scaledMountainousTerrain_ex;
            scaledMountainousTerrain_sb1.Scale = 0.25;
            scaledMountainousTerrain_sb1.Bias = 1.0;

            // 5: [Peak-height-multiplier module]: This multiplier module modulates the
            //    heights of the mountain peaks from the base-scaled-mountainous-terrain
            //    module using the output value from the scaled-peak-modulation module.
            Multiply scaledMountainousTerrain_mu = new Multiply();
            scaledMountainousTerrain_mu[0] =
              scaledMountainousTerrain_sb0;
            scaledMountainousTerrain_mu[1] =
              scaledMountainousTerrain_sb1;

            // 6: [Scaled-mountainous-terrain group]: Caches the output value from the
            //    peak-height-multiplier module.  This is the output value for the
            //    entire scaled-mountainous-terrain group.
            Cache scaledMountainousTerrain = new Cache();
            scaledMountainousTerrain[0] = scaledMountainousTerrain_mu;


            ////////////////////////////////////////////////////////////////////////////
            // Module group: scaled hilly terrain
            ////////////////////////////////////////////////////////////////////////////

            ////////////////////////////////////////////////////////////////////////////
            // Module subgroup: scaled hilly terrain (6 noise modules)
            //
            // This subgroup scales the output value from the hilly-terrain group so
            // that it can be added to the elevation defined by the continent-
            // definition group.  The scaling amount applied to the hills is one half of
            // the scaling amount applied to the scaled-mountainous-terrain group.
            //
            // This subgroup scales the output value such that it is almost always
            // positive.  This is done so that negative elevations are not applied to
            // the continent-definition group, preventing parts of the continent-
            // definition group from having negative terrain features "stamped" into it.
            //
            // The output value from this module subgroup is measured in planetary
            // elevation units (-1.0 for the lowest underwater trenches and +1.0 for the
            // highest mountain peaks.)
            //

            // 1: [Base-scaled-hilly-terrain module]: This scale/bias module scales the
            //    output value from the hilly-terrain group so that this output value is
            //    measured in planetary elevation units 
            ScaleBias scaledHillyTerrain_sb0 = new ScaleBias();
            scaledHillyTerrain_sb0[0] = hillyTerrain;
            scaledHillyTerrain_sb0.Scale = 0.0625;
            scaledHillyTerrain_sb0.Bias = 0.0625;

            // 2: [Base-hilltop-modulation module]: At this stage, most hilltops have
            //    roughly the same elevation.  This Perlin-noise module generates some
            //    random values that will be used by subsequent noise modules to
            //    randomly change the elevations of the hilltops.
            Perlin scaledHillyTerrain_pe = new Perlin();
            scaledHillyTerrain_pe.Seed = CUR_SEED + 120;
            scaledHillyTerrain_pe.Frequency = 13.5;
            scaledHillyTerrain_pe.Persistence = 0.5;
            scaledHillyTerrain_pe.Lacunarity = HILLS_LACUNARITY;
            scaledHillyTerrain_pe.OctaveCount = 6;
            scaledHillyTerrain_pe.Quality = QualityMode.Medium;

            // 3: [Hilltop-modulation module]: This exponential-curve module applies an
            //    exponential curve to the output value from the base-hilltop-modulation
            //    module.  This produces a small number of high values and a much larger
            //    number of low values.  This means there will be a few hilltops with
            //    much higher elevations than the majority of the hilltops, making the
            //    terrain features more varied.
            Exponent scaledHillyTerrain_ex = new Exponent();
            scaledHillyTerrain_ex[0] = scaledHillyTerrain_pe;
            scaledHillyTerrain_ex.Value = 1.25;

            // 4: [Scaled-hilltop-modulation module]: This scale/bias module modifies
            //    the range of the output value from the hilltop-modulation module so
            //    that it can be used as the modulator for the hilltop-height-multiplier
            //    module.  It is important that this output value is not much lower than
            //    1.0.
            ScaleBias scaledHillyTerrain_sb1 = new ScaleBias();
            scaledHillyTerrain_sb1[0] = scaledHillyTerrain_ex;
            scaledHillyTerrain_sb1.Scale = 0.5;
            scaledHillyTerrain_sb1.Bias = 1.5;

            // 5: [Hilltop-height-multiplier module]: This multiplier module modulates
            //    the heights of the hilltops from the base-scaled-hilly-terrain module
            //    using the output value from the scaled-hilltop-modulation module.
            Multiply scaledHillyTerrain_mu = new Multiply();
            scaledHillyTerrain_mu[0] = scaledHillyTerrain_sb0;
            scaledHillyTerrain_mu[1] = scaledHillyTerrain_sb1;

            // 6: [Scaled-hilly-terrain group]: Caches the output value from the
            //    hilltop-height-multiplier module.  This is the output value for the
            //    entire scaled-hilly-terrain group.
            Cache scaledHillyTerrain = new Cache();
            scaledHillyTerrain[0] = scaledHillyTerrain_mu;


            ////////////////////////////////////////////////////////////////////////////
            // Module group: scaled plains terrain
            ////////////////////////////////////////////////////////////////////////////

            ////////////////////////////////////////////////////////////////////////////
            // Module subgroup: scaled plains terrain (2 noise modules)
            //
            // This subgroup scales the output value from the plains-terrain group so
            // that it can be added to the elevations defined by the continent-
            // definition group.
            //
            // This subgroup scales the output value such that it is almost always
            // positive.  This is done so that negative elevations are not applied to
            // the continent-definition group, preventing parts of the continent-
            // definition group from having negative terrain features "stamped" into it.
            //
            // The output value from this module subgroup is measured in planetary
            // elevation units =  -1.0 for the lowest underwater trenches and +1.0 for the
            // highest mountain peaks.)
            //

            // 1: [Scaled-plains-terrain module]: This scale/bias module greatly
            //    flattens the output value from the plains terrain.  This output value
            //    is measured in planetary elevation units 
            ScaleBias scaledPlainsTerrain_sb = new ScaleBias();
            scaledPlainsTerrain_sb[0] = plainsTerrain;
            scaledPlainsTerrain_sb.Scale = 0.00390625;
            scaledPlainsTerrain_sb.Bias = 0.0078125;

            // 2: [Scaled-plains-terrain group]: Caches the output value from the
            //    scaled-plains-terrain module.  This is the output value for the entire
            //    scaled-plains-terrain group.
            Cache scaledPlainsTerrain = new Cache();
            scaledPlainsTerrain[0] = scaledPlainsTerrain_sb;


            ////////////////////////////////////////////////////////////////////////////
            // Module group: scaled badlands terrain
            ////////////////////////////////////////////////////////////////////////////

            ////////////////////////////////////////////////////////////////////////////
            // Module subgroup: scaled badlands terrain (2 noise modules)
            //
            // This subgroup scales the output value from the badlands-terrain group so
            // that it can be added to the elevations defined by the continent-
            // definition group.
            //
            // This subgroup scales the output value such that it is almost always
            // positive.  This is done so that negative elevations are not applied to
            // the continent-definition group, preventing parts of the continent-
            // definition group from having negative terrain features "stamped" into it.
            //
            // The output value from this module subgroup is measured in planetary
            // elevation units (-1.0 for the lowest underwater trenches and +1.0 for the
            // highest mountain peaks.)
            //

            // 1: [Scaled-badlands-terrain module]: This scale/bias module scales the
            //    output value from the badlands-terrain group so that it is measured
            //    in planetary elevation units 
            ScaleBias scaledBadlandsTerrain_sb = new ScaleBias();
            scaledBadlandsTerrain_sb[0] = badlandsTerrain;
            scaledBadlandsTerrain_sb.Scale = 0.0625;
            scaledBadlandsTerrain_sb.Bias = 0.0625;

            // 2: [Scaled-badlands-terrain group]: Caches the output value from the
            //    scaled-badlands-terrain module.  This is the output value for the
            //    entire scaled-badlands-terrain group.
            Cache scaledBadlandsTerrain = new Cache();
            scaledBadlandsTerrain[0] = scaledBadlandsTerrain_sb;


            ////////////////////////////////////////////////////////////////////////////
            // Module group: final planet
            ////////////////////////////////////////////////////////////////////////////

            ////////////////////////////////////////////////////////////////////////////
            // Module subgroup: continental shelf (6 noise modules)
            //
            // This module subgroup creates the continental shelves.
            //
            // The output value from this module subgroup are measured in planetary
            // elevation units (-1.0 for the lowest underwater trenches and +1.0 for the
            // highest mountain peaks.)
            //

            // 1: [Shelf-creator module]: This terracing module applies a terracing
            //    curve to the continent-definition group at the specified shelf level.
            //    This terrace becomes the continental shelf.  Note that this terracing
            //    module also places another terrace below the continental shelf near
            //    -1.0.  The bottom of this terrace is defined as the bottom of the
            //    ocean; subsequent noise modules will later add oceanic trenches to the
            //    bottom of the ocean.
            Terrace continentalShelf_te = new Terrace();
            continentalShelf_te[0] = continentDef;
            continentalShelf_te.Add(-1.0);
            continentalShelf_te.Add(-0.75);
            continentalShelf_te.Add(SHELF_LEVEL);
            continentalShelf_te.Add(1.0);

            // 2: [Oceanic-trench-basis module]: This ridged-multifractal-noise module
            //    generates some coherent noise that will be used to generate the
            //    oceanic trenches.  The ridges represent the bottom of the trenches.
            RiggedMultifractal continentalShelf_rm = new RiggedMultifractal();
            continentalShelf_rm.Seed = CUR_SEED + 130;
            continentalShelf_rm.Frequency = CONTINENT_FREQUENCY * 4.375;
            continentalShelf_rm.Lacunarity = CONTINENT_LACUNARITY;
            continentalShelf_rm.OctaveCount = 16;
            continentalShelf_rm.Quality = QualityMode.High;

            // 3: [Oceanic-trench module]: This scale/bias module inverts the ridges
            //    from the oceanic-trench-basis-module so that the ridges become
            //    trenches.  This noise module also reduces the depth of the trenches so
            //    that their depths are measured in planetary elevation units.
            ScaleBias continentalShelf_sb = new ScaleBias();
            continentalShelf_sb[0] = continentalShelf_rm;
            continentalShelf_sb.Scale = -0.125;
            continentalShelf_sb.Bias = -0.125;

            // 4: [Clamped-sea-bottom module]: This clamping module clamps the output
            //    value from the shelf-creator module so that its possible range is
            //    from the bottom of the ocean to sea level.  This is done because this
            //    subgroup is only concerned about the oceans.
            Clamp continentalShelf_cl = new Clamp();
            continentalShelf_cl[0] = continentalShelf_te;
            continentalShelf_cl.Minimum = -0.75;
            continentalShelf_cl.Maximum = SEA_LEVEL;

            // 5: [Shelf-and-trenches module]: This addition module adds the oceanic
            //    trenches to the clamped-sea-bottom module.
            Add continentalShelf_ad = new Add();
            continentalShelf_ad[0] = continentalShelf_sb;
            continentalShelf_ad[1] = continentalShelf_cl;

            // 6: [Continental-shelf subgroup]: Caches the output value from the shelf-
            //    and-trenches module.
            Cache continentalShelf = new Cache();
            continentalShelf[0] = continentalShelf_ad;


            ////////////////////////////////////////////////////////////////////////////
            // Module group: base continent elevations (3 noise modules)
            //
            // This subgroup generates the base elevations for the continents, before
            // terrain features are added.
            //
            // The output value from this module subgroup is measured in planetary
            // elevation units (-1.0 for the lowest underwater trenches and +1.0 for the
            // highest mountain peaks.)
            //

            // 1: [Base-scaled-continent-elevations module]: This scale/bias module
            //    scales the output value from the continent-definition group so that it
            //    is measured in planetary elevation units 
            ScaleBias baseContinentElev_sb = new ScaleBias();
            baseContinentElev_sb[0] = continentDef;
            baseContinentElev_sb.Scale = CONTINENT_HEIGHT_SCALE;
            baseContinentElev_sb.Bias = 0.0;

            // 2: [Base-continent-with-oceans module]: This selector module applies the
            //    elevations of the continental shelves to the base elevations of the
            //    continent.  It does this by selecting the output value from the
            //    continental-shelf subgroup if the corresponding output value from the
            //    continent-definition group is below the shelf level.  Otherwise, it
            //    selects the output value from the base-scaled-continent-elevations
            //    module.
            Select baseContinentElev_se = new Select();
            baseContinentElev_se[0] = baseContinentElev_sb;
            baseContinentElev_se[1] = continentalShelf;
            baseContinentElev_se.Controller = continentDef;
            baseContinentElev_se.Minimum = SHELF_LEVEL - 1000.0;
            baseContinentElev_se.Maximum = SHELF_LEVEL;
            baseContinentElev_se.FallOff = 0.03125;

            // 3: [Base-continent-elevation subgroup]: Caches the output value from the
            //    base-continent-with-oceans module.
            Cache baseContinentElev = new Cache();
            baseContinentElev[0] = baseContinentElev_se;


            ////////////////////////////////////////////////////////////////////////////
            // Module subgroup: continents with plains (2 noise modules)
            //
            // This subgroup applies the scaled-plains-terrain group to the base-
            // continent-elevation subgroup.
            //
            // The output value from this module subgroup is measured in planetary
            // elevation units (-1.0 for the lowest underwater trenches and +1.0 for the
            // highest mountain peaks.)
            //

            // 1: [Continents-with-plains module]:  This addition module adds the
            //    scaled-plains-terrain group to the base-continent-elevation subgroup.
            Add continentsWithPlains_ad = new Add();
            continentsWithPlains_ad[0] = baseContinentElev;
            continentsWithPlains_ad[1] = scaledPlainsTerrain;

            // 2: [Continents-with-plains subgroup]: Caches the output value from the
            //    continents-with-plains module.
            Cache continentsWithPlains = new Cache();
            continentsWithPlains[0] = continentsWithPlains_ad;


            ////////////////////////////////////////////////////////////////////////////
            // Module subgroup: continents with hills (3 noise modules)
            //
            // This subgroup applies the scaled-hilly-terrain group to the continents-
            // with-plains subgroup.
            //
            // The output value from this module subgroup is measured in planetary
            // elevation units (-1.0 for the lowest underwater trenches and +1.0 for the
            // highest mountain peaks.)
            //

            // 1: [Continents-with-hills module]:  This addition module adds the scaled-
            //    hilly-terrain group to the base-continent-elevation subgroup.
            Add continentsWithHills_ad = new Add();
            continentsWithHills_ad[0] = baseContinentElev;
            continentsWithHills_ad[1] = scaledHillyTerrain;

            // 2: [Select-high-elevations module]: This selector module ensures that
            //    the hills only appear at higher elevations.  It does this by selecting
            //    the output value from the continent-with-hills module if the
            //    corresponding output value from the terrain-type-defintion group is
            //    above a certain value. Otherwise, it selects the output value from the
            //    continents-with-plains subgroup.
            Select continentsWithHills_se = new Select();
            continentsWithHills_se[0] = continentsWithPlains;
            continentsWithHills_se[1] = continentsWithHills_ad;
            continentsWithHills_se.Controller = terrainTypeDef;
            continentsWithHills_se.Minimum = 1.0 - HILLS_AMOUNT;
            continentsWithHills_se.Maximum = 1001.0 - HILLS_AMOUNT;
            continentsWithHills_se.FallOff = 0.25;

            // 3: [Continents-with-hills subgroup]: Caches the output value from the
            //    select-high-elevations module.
            Cache continentsWithHills = new Cache();
            continentsWithHills[0] = continentsWithHills_se;


            ////////////////////////////////////////////////////////////////////////////
            // Module subgroup: continents with mountains (5 noise modules)
            //
            // This subgroup applies the scaled-mountainous-terrain group to the
            // continents-with-hills subgroup.
            //
            // The output value from this module subgroup is measured in planetary
            // elevation units (-1.0 for the lowest underwater trenches and +1.0 for the
            // highest mountain peaks.)
            //

            // 1: [Continents-and-mountains module]:  This addition module adds the
            //    scaled-mountainous-terrain group to the base-continent-elevation
            //    subgroup.
            Add continentsWithMountains_ad0 = new Add();
            continentsWithMountains_ad0[0] = baseContinentElev;
            continentsWithMountains_ad0[1] = scaledMountainousTerrain;

            // 2: [Increase-mountain-heights module]:  This curve module applies a curve
            //    to the output value from the continent-definition group.  This
            //    modified output value is used by a subsequent noise module to add
            //    additional height to the mountains based on the current continent
            //    elevation.  The higher the continent elevation, the higher the
            //    mountains.
            Curve continentsWithMountains_cu = new Curve();
            continentsWithMountains_cu[0] = continentDef;
            continentsWithMountains_cu.Add(-1.0, -0.0625);
            continentsWithMountains_cu.Add(0.0, 0.0000);
            continentsWithMountains_cu.Add(1.0 - MOUNTAINS_AMOUNT, 0.0625);
            continentsWithMountains_cu.Add(1.0, 0.2500);

            // 3: [Add-increased-mountain-heights module]: This addition module adds
            //    the increased-mountain-heights module to the continents-and-
            //    mountains module.  The highest continent elevations now have the
            //    highest mountains.
            Add continentsWithMountains_ad1 = new Add();
            continentsWithMountains_ad1[0] = continentsWithMountains_ad0;
            continentsWithMountains_ad1[1] = continentsWithMountains_cu;

            // 4: [Select-high-elevations module]: This selector module ensures that
            //    mountains only appear at higher elevations.  It does this by selecting
            //    the output value from the continent-with-mountains module if the
            //    corresponding output value from the terrain-type-defintion group is
            //    above a certain value.  Otherwise, it selects the output value from
            //    the continents-with-hills subgroup.  Note that the continents-with-
            //    hills subgroup also contains the plains terrain.
            Select continentsWithMountains_se = new Select();
            continentsWithMountains_se[0] = continentsWithHills;
            continentsWithMountains_se[1] = continentsWithMountains_ad1;
            continentsWithMountains_se.Controller = terrainTypeDef;
            continentsWithMountains_se.Minimum = 1.0 - MOUNTAINS_AMOUNT;
            continentsWithMountains_se.Maximum = 1001.0 - MOUNTAINS_AMOUNT;
            continentsWithMountains_se.FallOff = 0.25;

            // 5: [Continents-with-mountains subgroup]: Caches the output value from
            //    the select-high-elevations module.
            Cache continentsWithMountains = new Cache();
            continentsWithMountains[0] = continentsWithMountains_se;


            ////////////////////////////////////////////////////////////////////////////
            // Module subgroup: continents with badlands (5 noise modules)
            //
            // This subgroup applies the scaled-badlands-terrain group to the
            // continents-with-mountains subgroup.
            //
            // The output value from this module subgroup is measured in planetary
            // elevation units (-1.0 for the lowest underwater trenches and +1.0 for the
            // highest mountain peaks.)
            //

            // 1: [Badlands-positions module]: This Perlin-noise module generates some
            //    random noise, which is used by subsequent noise modules to specify the
            //    locations of the badlands.
            Perlin continentsWithBadlands_pe = new Perlin();
            continentsWithBadlands_pe.Seed = CUR_SEED + 140;
            continentsWithBadlands_pe.Frequency = 16.5;
            continentsWithBadlands_pe.Persistence = 0.5;
            continentsWithBadlands_pe.Lacunarity = CONTINENT_LACUNARITY;
            continentsWithBadlands_pe.OctaveCount = 2;
            continentsWithBadlands_pe.Quality = QualityMode.Medium;

            // 2: [Continents-and-badlands module]:  This addition module adds the
            //    scaled-badlands-terrain group to the base-continent-elevation
            //    subgroup.
            Add continentsWithBadlands_ad = new Add();
            continentsWithBadlands_ad[0] = baseContinentElev;
            continentsWithBadlands_ad[1] = scaledBadlandsTerrain;

            // 3: [Select-badlands-positions module]: This selector module places
            //    badlands at random spots on the continents based on the Perlin noise
            //    generated by the badlands-positions module.  To do this, it selects
            //    the output value from the continents-and-badlands module if the
            //    corresponding output value from the badlands-position module is
            //    greater than a specified value.  Otherwise, this selector module
            //    selects the output value from the continents-with-mountains subgroup.
            //    There is also a wide transition between these two noise modules so
            //    that the badlands can blend into the rest of the terrain on the
            //    continents.
            Select continentsWithBadlands_se = new Select();
            continentsWithBadlands_se[0] = continentsWithMountains;
            continentsWithBadlands_se[1] = continentsWithBadlands_ad;
            continentsWithBadlands_se.Controller = continentsWithBadlands_pe;
            continentsWithBadlands_se.Minimum = 1.0 - BADLANDS_AMOUNT;
            continentsWithBadlands_se.Maximum = 1001.0 - BADLANDS_AMOUNT;
            continentsWithBadlands_se.FallOff = 0.25;

            // 4: [Apply-badlands module]: This maximum-value module causes the badlands
            //    to "poke out" from the rest of the terrain.  It does this by ensuring
            //    that only the maximum of the output values from the continents-with-
            //    mountains subgroup and the select-badlands-positions modules
            //    contribute to the output value of this subgroup.  One side effect of
            //    this process is that the badlands will not appear in mountainous
            //    terrain.
            Max continentsWithBadlands_ma = new Max();
            continentsWithBadlands_ma[0] = continentsWithMountains;
            continentsWithBadlands_ma[1] = continentsWithBadlands_se;

            // 5: [Continents-with-badlands subgroup]: Caches the output value from the
            //    apply-badlands module.
            Cache continentsWithBadlands = new Cache();
            continentsWithBadlands[0] = continentsWithBadlands_ma;


            ////////////////////////////////////////////////////////////////////////////
            // Module subgroup: continents with rivers (4 noise modules)
            //
            // This subgroup applies the river-positions group to the continents-with-
            // badlands subgroup.
            //
            // The output value from this module subgroup is measured in planetary
            // elevation units (-1.0 for the lowest underwater trenches and +1.0 for the
            // highest mountain peaks.)
            //

            // 1: [Scaled-rivers module]: This scale/bias module scales the output value
            //    from the river-positions group so that it is measured in planetary
            //    elevation units and is negative; this is required for step 2.
            ScaleBias continentsWithRivers_sb = new ScaleBias();
            continentsWithRivers_sb[0] = riverPositions;
            continentsWithRivers_sb.Scale = RIVER_DEPTH / 2.0;
            continentsWithRivers_sb.Bias = -RIVER_DEPTH / 2.0;

            // 2: [Add-rivers-to-continents module]: This addition module adds the
            //    rivers to the continents-with-badlands subgroup.  Because the scaled-
            //    rivers module only outputs a negative value, the scaled-rivers module
            //    carves the rivers out of the terrain.
            Add continentsWithRivers_ad = new Add();
            continentsWithRivers_ad[0] = continentsWithBadlands;
            continentsWithRivers_ad[1] = continentsWithRivers_sb;

            // 3: [Blended-rivers-to-continents module]: This selector module outputs
            //    deep rivers near sea level and shallower rivers in higher terrain.  It
            //    does this by selecting the output value from the continents-with-
            //    badlands subgroup if the corresponding output value from the
            //    continents-with-badlands subgroup is far from sea level.  Otherwise,
            //    this selector module selects the output value from the add-rivers-to-
            //    continents module.
            Select continentsWithRivers_se = new Select();
            continentsWithRivers_se[0] = continentsWithBadlands;
            continentsWithRivers_se[1] = continentsWithRivers_ad;
            continentsWithRivers_se.Controller = continentsWithBadlands;
            continentsWithRivers_se.Minimum = SEA_LEVEL;
            continentsWithRivers_se.Maximum = CONTINENT_HEIGHT_SCALE + SEA_LEVEL;
            continentsWithRivers_se.FallOff = CONTINENT_HEIGHT_SCALE - SEA_LEVEL;

            // 4: [Continents-with-rivers subgroup]: Caches the output value from the
            //    blended-rivers-to-continents module.
            Cache continentsWithRivers = new Cache();
            continentsWithRivers[0] = continentsWithRivers_se;


            ////////////////////////////////////////////////////////////////////////////
            // Module subgroup: unscaled final planet (1 noise module)
            //
            // This subgroup simply caches the output value from the continent-with-
            // rivers subgroup to contribute to the final output value.
            //

            // 1: [Unscaled-final-planet subgroup]: Caches the output value from the
            //    continent-with-rivers subgroup.
            Cache unscaledFinalPlanet = new Cache();
            unscaledFinalPlanet[0] = continentsWithRivers;


            ////////////////////////////////////////////////////////////////////////////
            // Module subgroup: final planet (2 noise modules)
            //
            // This subgroup scales the output value from the unscaled-final-planet
            // subgroup so that it represents an elevation in meters.
            //

            // 1: [Final-planet-in-meters module]: This scale/bias module scales the
            //    output value from the unscaled-final-planet subgroup so that its
            //    output value is measured in meters.
            ScaleBias finalPlanet_sb = new ScaleBias();
            finalPlanet_sb[0] = unscaledFinalPlanet;
            finalPlanet_sb.Scale = (MAX_ELEV - MIN_ELEV) / 2.0;
            finalPlanet_sb.Bias = MIN_ELEV + ((MAX_ELEV - MIN_ELEV) / 2.0);

            // 2: [Final-planet group]: Caches the output value from the final-planet-
            //    in-meters module.  Stick a fork in it, we're done!
            Cache finalPlanet = new Cache();
            finalPlanet[0] = finalPlanet_sb;


            ////////////////////////////////////////////////////////////////////////////
            // Check constants
            //
            // This checks the constants entered at the top of the file to make sure
            // they are valid.

            Debug.Assert(SOUTH_COORD < NORTH_COORD);
            Debug.Assert(WEST_COORD < EAST_COORD);
            Debug.Assert(GRID_WIDTH > 0);
            Debug.Assert(GRID_HEIGHT > 0);
            Debug.Assert(PLANET_CIRCUMFERENCE >= 1.0);
            Debug.Assert(MIN_ELEV < MAX_ELEV);
            Debug.Assert(CONTINENT_FREQUENCY >= 1.0);
            Debug.Assert(CONTINENT_LACUNARITY >= 1.0);
            Debug.Assert(CONTINENT_LACUNARITY <= 4.0);
            Debug.Assert(MOUNTAIN_LACUNARITY >= 1.0);
            Debug.Assert(MOUNTAIN_LACUNARITY <= 4.0);
            Debug.Assert(HILLS_LACUNARITY >= 1.0);
            Debug.Assert(HILLS_LACUNARITY <= 4.0);
            Debug.Assert(PLAINS_LACUNARITY >= 1.0);
            Debug.Assert(PLAINS_LACUNARITY <= 4.0);
            Debug.Assert(BADLANDS_LACUNARITY >= 1.0);
            Debug.Assert(BADLANDS_LACUNARITY <= 4.0);
            Debug.Assert(MOUNTAINS_TWIST >= 0.0);
            Debug.Assert(HILLS_TWIST >= 0.0);
            Debug.Assert(BADLANDS_TWIST >= 0.0);
            Debug.Assert(SEA_LEVEL >= -1.0);
            Debug.Assert(SEA_LEVEL <= 1.0);
            Debug.Assert(SHELF_LEVEL >= -1.0);
            Debug.Assert(SHELF_LEVEL <= 1.0);
            Debug.Assert(SEA_LEVEL > SHELF_LEVEL);
            Debug.Assert(MOUNTAINS_AMOUNT >= 0.0);
            Debug.Assert(MOUNTAINS_AMOUNT <= 1.0);
            Debug.Assert(HILLS_AMOUNT >= 0.0);
            Debug.Assert(HILLS_AMOUNT <= 1.0);
            Debug.Assert(BADLANDS_AMOUNT >= 0.0);
            Debug.Assert(BADLANDS_AMOUNT <= 1.0);
            Debug.Assert(MOUNTAINS_AMOUNT < HILLS_AMOUNT);
            Debug.Assert(MOUNTAIN_GLACIATION >= 1.0);
            Debug.Assert(RIVER_DEPTH >= 0.0);


            ////////////////////////////////////////////////////////////////////////////
            // Create the elevation grid and resulting images

            // First, create a spherical-noise-map builder.
            NoiseMapBuilderSphere planet = new NoiseMapBuilderSphere();
            NoiseMap elevGrid = new NoiseMap();

            // Pass in the boundaries of the elevation grid to extract.
            planet.SetBounds(SOUTH_COORD, NORTH_COORD, WEST_COORD, EAST_COORD);
            planet.SetDestSize(GRID_WIDTH, GRID_HEIGHT);

            // Build the elevation grid with the output values from the final-planet
            // group.
            planet.SetSourceModule(finalPlanet);
            planet.SetDestNoiseMap(elevGrid);
            planet.Build();

            // Calculate the spatial resolution of the elevation grid, in meters.
            // Assume that the spatial resolution is the same in both the x and y
            // directions.  This is needed by the Terragen file writer.
            double degExtent = EAST_COORD - WEST_COORD;
            double gridExtent = (double)GRID_WIDTH;
            double metersPerDegree = PLANET_CIRCUMFERENCE / 360.0;
            double resInMeters = (degExtent / gridExtent) * metersPerDegree;

#if TODO
  // Write the elevation grid as a Terragen terrain file (*.ter).
  if (resInMeters <= 240.0) {
    WriterTER terrainWriter;
    terrainWriter.SourceNoiseMap (elevGrid);
    terrainWriter.DestFilename ("terrain.ter");
    terrainWriter.MetersPerPoint (resInMeters);
    terrainWriter.WriteDestFile ();
  }


#endif
            // Write the elevation grid as a raw file (*.raw)
            using (BinaryWriter bw = new BinaryWriter(new FileStream(dirname + "terrain.raw", FileMode.OpenOrCreate)))
            {
                bw.Write(elevGrid.Width);
                bw.Write(elevGrid.Height);
                for (int x = 0; x < GRID_WIDTH; x++)
                {
                    for (int y = 0; y < GRID_HEIGHT; y++)
                    {
                        bw.Write(elevGrid[x, y]);
                    }
                }
                bw.Close();
            }

            // Calculate the sea level, in meters.
            double seaLevelInMeters = (((SEA_LEVEL + 1.0) / 2.0) * (MAX_ELEV - MIN_ELEV)) + MIN_ELEV;

            // Now generate an image that is colored by elevation and has an artificial
            // light-source.
            NoiseImage destImage = new NoiseImage();
            RendererImage imageRenderer = new RendererImage();
            imageRenderer.SetSourceNoiseMap(elevGrid);
            imageRenderer.SetDestImage(destImage);
            imageRenderer.ClearGradient();
            imageRenderer.AddGradientPoint(-16384.0 + seaLevelInMeters, new Color(0, 0, 0, 255));
            imageRenderer.AddGradientPoint(-256 + seaLevelInMeters, new Color(6, 58, 127, 255));
            imageRenderer.AddGradientPoint(-1.0 + seaLevelInMeters, new Color(14, 112, 192, 255));
            imageRenderer.AddGradientPoint(0.0 + seaLevelInMeters, new Color(70, 120, 60, 255));
            imageRenderer.AddGradientPoint(1024.0 + seaLevelInMeters, new Color(110, 140, 75, 255));
            imageRenderer.AddGradientPoint(2048.0 + seaLevelInMeters, new Color(160, 140, 111, 255));
            imageRenderer.AddGradientPoint(3072.0 + seaLevelInMeters, new Color(184, 163, 141, 255));
            imageRenderer.AddGradientPoint(4096.0 + seaLevelInMeters, new Color(255, 255, 255, 255));
            imageRenderer.AddGradientPoint(6144.0 + seaLevelInMeters, new Color(128, 255, 255, 255));
            imageRenderer.AddGradientPoint(16384.0 + seaLevelInMeters, new Color(0, 0, 255, 255));
            imageRenderer.EnableLight(true);
            imageRenderer.SetLightContrast(1.0 / resInMeters);
            imageRenderer.SetLightIntensity(2.0);
            imageRenderer.SetLightElev(45.0);
            imageRenderer.SetLightAzimuth(135.0);
            imageRenderer.Render();

            // Write the image as a Windows bitmap file (*.bmp).
            WriterBMP bitmapWriter = new WriterBMP();
            bitmapWriter.SetSourceImage(destImage);
            bitmapWriter.SetDestFilename(dirname + "terrain.bmp");
            bitmapWriter.WriteDestFile();

            // Flatten the seas that are deeper than 15 meters or so.  We do not flatten
            // all the seas so that we can color the shallow areas with a different
            // color than the deeper seas.
            const double DEEP_SEA_LEVEL = -256.0;
#if TODO
    for (y = 0; y < GRID_HEIGHT; y++) {
    float* pCur = elevGrid.GetSlabPtr (y);
    for (x = 0; x < GRID_WIDTH; x++) {
      if (*pCur < (SEA_LEVEL + DEEP_SEA_LEVEL)) {
        *pCur = (SEA_LEVEL + DEEP_SEA_LEVEL;
      }
      ++pCur;
    }
  }
#endif

            // Now generate the surface map.  This is an unshaded map that is colored by
            // elevation.  Using OpenGL or another 3D API, a surface map can be used in
            // conjunction with a normal map to light the map in any direction in real
            // time.
            RendererImage surfaceRenderer = new RendererImage();
            surfaceRenderer.SetSourceNoiseMap(elevGrid);
            surfaceRenderer.SetDestImage(destImage);
            //surfaceRenderer.ClearGradient();
            //surfaceRenderer.AddGradientPoint(-16384.0 + seaLevelInMeters, new Color(3, 29, 63, 255));
            //surfaceRenderer.AddGradientPoint(DEEP_SEA_LEVEL + seaLevelInMeters, new Color(3, 29, 63, 255));
            //surfaceRenderer.AddGradientPoint(-1.0 + seaLevelInMeters, new Color(7, 106, 127, 255));
            //surfaceRenderer.AddGradientPoint(0.0 + seaLevelInMeters, new Color(62, 86, 30, 255));
            //surfaceRenderer.AddGradientPoint(1024.0 + seaLevelInMeters, new Color(84, 96, 50, 255));
            //surfaceRenderer.AddGradientPoint(2048.0 + seaLevelInMeters, new Color(130, 127, 97, 255));
            //surfaceRenderer.AddGradientPoint(3072.0 + seaLevelInMeters, new Color(184, 163, 141, 255));
            //surfaceRenderer.AddGradientPoint(4096.0 + seaLevelInMeters, new Color(255, 255, 255, 255));
            //surfaceRenderer.AddGradientPoint(6144.0 + seaLevelInMeters, new Color(128, 255, 255, 255));
            //surfaceRenderer.AddGradientPoint(16384.0 + seaLevelInMeters, new Color(0, 0, 255, 255));
            surfaceRenderer.Gradient = Palette.TOPO_15LEV;
            surfaceRenderer.EnableLight(false);
            surfaceRenderer.Render();

            // Write the image as a Windows bitmap file (*.bmp).
            bitmapWriter.SetSourceImage(destImage);
            bitmapWriter.SetDestFilename(dirname + "terrainsurface.bmp");
            bitmapWriter.WriteDestFile();

            //// Now generate the specularity map.  This defines the "shininess" of the
            //// elevation grid.  Water areas are the shiniest.
            //RendererImage specularityRenderer = new RendererImage();
            //specularityRenderer.SetSourceNoiseMap(elevGrid);
            //specularityRenderer.SetDestImage(destImage);
            //specularityRenderer.ClearGradient();
            //specularityRenderer.AddGradientPoint(MIN_ELEV, new Color(255, 255, 255, 255));
            //specularityRenderer.AddGradientPoint(seaLevelInMeters, new Color(255, 255, 255, 255));
            //specularityRenderer.AddGradientPoint(seaLevelInMeters + 1.0, new Color(0, 0, 0, 255));
            //specularityRenderer.AddGradientPoint(MAX_ELEV, new Color(128, 128, 128, 255));
            //specularityRenderer.EnableLight(false);
            //specularityRenderer.Render();

            //// Write the specularity map as a Windows bitmap file (*.bmp).
            //bitmapWriter.SetSourceImage(destImage);
            //bitmapWriter.SetDestFilename("terrainspec.bmp");
            //bitmapWriter.WriteDestFile();

            RendererImage heightmapRenderer = new RendererImage();
            heightmapRenderer.SetSourceNoiseMap(elevGrid);
            heightmapRenderer.SetDestImage(destImage);
            heightmapRenderer.ClearGradient();
            heightmapRenderer.AddGradientPoint(MIN_ELEV, new Color(0, 0, 0, 255));
            heightmapRenderer.AddGradientPoint(seaLevelInMeters+1, new Color(1, 1, 1, 255));
            heightmapRenderer.AddGradientPoint(MAX_ELEV, new Color(255, 255, 255, 255));
            heightmapRenderer.Render();

            // Write the specularity map as a Windows bitmap file (*.bmp).
            bitmapWriter.SetSourceImage(destImage);
            bitmapWriter.SetDestFilename(dirname + "heightmap.bmp");
            bitmapWriter.WriteDestFile();

            //// Finally, render the normal map.  Using OpenGL or another 3D API, a
            //// surface map can be used in conjunction with a normal map to light the map
            //// in any direction in real time.
            //RendererNormalMap normalMapRenderer = new RendererNormalMap();
            //normalMapRenderer.SetSourceNoiseMap(elevGrid);
            //normalMapRenderer.SetDestImage(destImage);
            //normalMapRenderer.SetBumpHeight(1.0 / resInMeters);
            //normalMapRenderer.Render();

            //// Write the normal map as a Windows bitmap file (*.bmp).
            //bitmapWriter.SetSourceImage(destImage);
            //bitmapWriter.SetDestFilename("terrainnormal.bmp");
            //bitmapWriter.WriteDestFile();

            return elevGrid.Map;
        }

        private static float[,] ReadElevation()
        {
            float[,] hm = null;
            // Write the elevation grid as a raw file (*.raw)
            if (!File.Exists(dirname + "terrain.raw"))
                return null;
            using (BinaryReader br = new BinaryReader(new FileStream(dirname + "terrain.raw", FileMode.Open)))
            {

                int w = br.ReadInt32();
                int h = br.ReadInt32();
                hm = new float[w, h];
                for (int x = 0; x < w; x++)
                {
                    for (int y = 0; y < h; y++)
                    {
                        hm[x, y] = br.ReadSingle();
                    }
                }
                br.Close();
            }
            return hm;
        }
    }
}
